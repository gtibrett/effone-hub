"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `CircuitDescription`."""
  circuitDescriptionsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CircuitDescription`."""
    orderBy: [CircuitDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CircuitDescriptionCondition
  ): CircuitDescriptionsConnection

  """Reads a set of `CircuitDescription`."""
  circuitDescriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CircuitDescription`."""
    orderBy: [CircuitDescriptionsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CircuitDescriptionCondition
  ): [CircuitDescription!]

  """Reads and enables pagination through a set of `Circuit`."""
  circuitsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Circuit`."""
    orderBy: [CircuitsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CircuitCondition
  ): CircuitsConnection

  """Reads a set of `Circuit`."""
  circuits(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Circuit`."""
    orderBy: [CircuitsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CircuitCondition
  ): [Circuit!]

  """Reads and enables pagination through a set of `DriverCurrentTeam`."""
  driverCurrentTeamsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverCurrentTeam`."""
    orderBy: [DriverCurrentTeamsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverCurrentTeamCondition
  ): DriverCurrentTeamsConnection

  """Reads a set of `DriverCurrentTeam`."""
  driverCurrentTeams(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverCurrentTeam`."""
    orderBy: [DriverCurrentTeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverCurrentTeamCondition
  ): [DriverCurrentTeam!]

  """Reads and enables pagination through a set of `DriverStanding`."""
  driverStandingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingCondition
  ): DriverStandingsConnection

  """Reads a set of `DriverStanding`."""
  driverStandings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingCondition
  ): [DriverStanding!]

  """
  Reads and enables pagination through a set of `DriverStandingsBySeason`.
  """
  driverStandingsBySeasonsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): DriverStandingsBySeasonsConnection

  """Reads a set of `DriverStandingsBySeason`."""
  driverStandingsBySeasons(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): [DriverStandingsBySeason!]

  """Reads and enables pagination through a set of `DriverTeam`."""
  driverTeamsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): DriverTeamsConnection

  """Reads a set of `DriverTeam`."""
  driverTeams(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): [DriverTeam!]

  """Reads and enables pagination through a set of `Driver`."""
  driversConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Driver`."""
    orderBy: [DriversOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverCondition
  ): DriversConnection

  """Reads a set of `Driver`."""
  drivers(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Driver`."""
    orderBy: [DriversOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverCondition
  ): [Driver!]

  """
  Reads and enables pagination through a set of `FinalTeamStandingsByYear`.
  """
  finalTeamStandingsByYearsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FinalTeamStandingsByYear`."""
    orderBy: [FinalTeamStandingsByYearsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FinalTeamStandingsByYearCondition
  ): FinalTeamStandingsByYearsConnection

  """Reads a set of `FinalTeamStandingsByYear`."""
  finalTeamStandingsByYears(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `FinalTeamStandingsByYear`."""
    orderBy: [FinalTeamStandingsByYearsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FinalTeamStandingsByYearCondition
  ): [FinalTeamStandingsByYear!]

  """Reads and enables pagination through a set of `LapTime`."""
  lapTimesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimeCondition
  ): LapTimesConnection

  """Reads a set of `LapTime`."""
  lapTimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimeCondition
  ): [LapTime!]

  """Reads and enables pagination through a set of `LapTimesWithStart`."""
  lapTimesWithStartsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `LapTimesWithStart`."""
    orderBy: [LapTimesWithStartsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimesWithStartCondition
  ): LapTimesWithStartsConnection

  """Reads a set of `LapTimesWithStart`."""
  lapTimesWithStarts(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LapTimesWithStart`."""
    orderBy: [LapTimesWithStartsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimesWithStartCondition
  ): [LapTimesWithStart!]

  """Reads and enables pagination through a set of `NextRaceBySeason`."""
  nextRaceBySeasonsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `NextRaceBySeason`."""
    orderBy: [NextRaceBySeasonsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NextRaceBySeasonCondition
  ): NextRaceBySeasonsConnection

  """Reads a set of `NextRaceBySeason`."""
  nextRaceBySeasons(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `NextRaceBySeason`."""
    orderBy: [NextRaceBySeasonsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NextRaceBySeasonCondition
  ): [NextRaceBySeason!]

  """Reads and enables pagination through a set of `PitStop`."""
  pitStopsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PitStopCondition
  ): PitStopsConnection

  """Reads a set of `PitStop`."""
  pitStops(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PitStopCondition
  ): [PitStop!]

  """Reads and enables pagination through a set of `Qualifying`."""
  qualifyingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): QualifyingsConnection

  """Reads a set of `Qualifying`."""
  qualifyings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): [Qualifying!]

  """Reads and enables pagination through a set of `Race`."""
  racesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RaceCondition
  ): RacesConnection

  """Reads a set of `Race`."""
  races(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RaceCondition
  ): [Race!]

  """Reads and enables pagination through a set of `Result`."""
  resultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): ResultsConnection

  """Reads a set of `Result`."""
  results(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): [Result!]

  """Reads and enables pagination through a set of `Season`."""
  seasonsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Season`."""
    orderBy: [SeasonsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SeasonCondition
  ): SeasonsConnection

  """Reads a set of `Season`."""
  seasons(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Season`."""
    orderBy: [SeasonsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SeasonCondition
  ): [Season!]

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): SprintResultsConnection

  """Reads a set of `SprintResult`."""
  sprintResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): [SprintResult!]

  """Reads and enables pagination through a set of `Status`."""
  statusesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Status`."""
    orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StatusCondition
  ): StatusesConnection

  """Reads a set of `Status`."""
  statuses(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Status`."""
    orderBy: [StatusesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StatusCondition
  ): [Status!]

  """Reads and enables pagination through a set of `TeamColor`."""
  teamColorsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamColor`."""
    orderBy: [TeamColorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamColorCondition
  ): TeamColorsConnection

  """Reads a set of `TeamColor`."""
  teamColors(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamColor`."""
    orderBy: [TeamColorsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamColorCondition
  ): [TeamColor!]

  """Reads and enables pagination through a set of `TeamHistory`."""
  teamHistoriesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamHistoryCondition
  ): TeamHistoriesConnection

  """Reads a set of `TeamHistory`."""
  teamHistories(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamHistoryCondition
  ): [TeamHistory!]

  """Reads and enables pagination through a set of `TeamResult`."""
  teamResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamResultCondition
  ): TeamResultsConnection

  """Reads a set of `TeamResult`."""
  teamResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamResultCondition
  ): [TeamResult!]

  """Reads and enables pagination through a set of `TeamStanding`."""
  teamStandingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamStandingCondition
  ): TeamStandingsConnection

  """Reads a set of `TeamStanding`."""
  teamStandings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamStandingCondition
  ): [TeamStanding!]

  """Reads and enables pagination through a set of `Team`."""
  teamsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamCondition
  ): TeamsConnection

  """Reads a set of `Team`."""
  teams(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamCondition
  ): [Team!]
  circuitDescription(circuitId: Int!): CircuitDescription
  circuit(circuitId: Int!): Circuit
  circuitByCircuitRef(circuitRef: String!): Circuit
  circuitByUrl(url: String!): Circuit
  driverCurrentTeamByDriverId(driverId: Int!): DriverCurrentTeam
  driverStanding(driverStandingsId: Int!): DriverStanding
  driver(driverId: Int!): Driver
  driverByDriverRef(driverRef: String!): Driver
  driverByUrl(url: String!): Driver
  lapTime(raceId: Int!, driverId: Int!, lap: Int!): LapTime
  nextRaceBySeasonByYear(year: Int!): NextRaceBySeason
  nextRaceBySeasonByRaceId(raceId: Int!): NextRaceBySeason
  pitStop(raceId: Int!, driverId: Int!, stop: Int!): PitStop
  qualifying(qualifyId: Int!): Qualifying
  race(raceId: Int!): Race
  raceByYearAndRound(year: Int!, round: Int!): Race
  result(resultId: Int!): Result
  season(year: Int!): Season
  seasonByUrl(url: String!): Season
  sprintResult(sprintResultId: Int!): SprintResult
  status(statusId: Int!): Status
  teamColor(teamId: Int!): TeamColor
  teamHistory(teamId: Int!, antecedentTeamId: Int!, startYear: Int!): TeamHistory
  teamResult(constructorResultsId: Int!): TeamResult
  teamStanding(constructorStandingsId: Int!): TeamStanding
  team(teamId: Int!): Team
  teamByConstructorRef(constructorRef: String!): Team

  """Reads a single `CircuitDescription` using its globally unique `ID`."""
  circuitDescriptionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CircuitDescription`.
    """
    nodeId: ID!
  ): CircuitDescription

  """Reads a single `Circuit` using its globally unique `ID`."""
  circuitByNodeId(
    """The globally unique `ID` to be used in selecting a single `Circuit`."""
    nodeId: ID!
  ): Circuit

  """Reads a single `DriverStanding` using its globally unique `ID`."""
  driverStandingByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `DriverStanding`.
    """
    nodeId: ID!
  ): DriverStanding

  """Reads a single `Driver` using its globally unique `ID`."""
  driverByNodeId(
    """The globally unique `ID` to be used in selecting a single `Driver`."""
    nodeId: ID!
  ): Driver

  """Reads a single `LapTime` using its globally unique `ID`."""
  lapTimeByNodeId(
    """The globally unique `ID` to be used in selecting a single `LapTime`."""
    nodeId: ID!
  ): LapTime

  """Reads a single `PitStop` using its globally unique `ID`."""
  pitStopByNodeId(
    """The globally unique `ID` to be used in selecting a single `PitStop`."""
    nodeId: ID!
  ): PitStop

  """Reads a single `Qualifying` using its globally unique `ID`."""
  qualifyingByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Qualifying`.
    """
    nodeId: ID!
  ): Qualifying

  """Reads a single `Race` using its globally unique `ID`."""
  raceByNodeId(
    """The globally unique `ID` to be used in selecting a single `Race`."""
    nodeId: ID!
  ): Race

  """Reads a single `Result` using its globally unique `ID`."""
  resultByNodeId(
    """The globally unique `ID` to be used in selecting a single `Result`."""
    nodeId: ID!
  ): Result

  """Reads a single `Season` using its globally unique `ID`."""
  seasonByNodeId(
    """The globally unique `ID` to be used in selecting a single `Season`."""
    nodeId: ID!
  ): Season

  """Reads a single `SprintResult` using its globally unique `ID`."""
  sprintResultByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `SprintResult`.
    """
    nodeId: ID!
  ): SprintResult

  """Reads a single `Status` using its globally unique `ID`."""
  statusByNodeId(
    """The globally unique `ID` to be used in selecting a single `Status`."""
    nodeId: ID!
  ): Status

  """Reads a single `TeamColor` using its globally unique `ID`."""
  teamColorByNodeId(
    """The globally unique `ID` to be used in selecting a single `TeamColor`."""
    nodeId: ID!
  ): TeamColor

  """Reads a single `TeamHistory` using its globally unique `ID`."""
  teamHistoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TeamHistory`.
    """
    nodeId: ID!
  ): TeamHistory

  """Reads a single `TeamResult` using its globally unique `ID`."""
  teamResultByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TeamResult`.
    """
    nodeId: ID!
  ): TeamResult

  """Reads a single `TeamStanding` using its globally unique `ID`."""
  teamStandingByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `TeamStanding`.
    """
    nodeId: ID!
  ): TeamStanding

  """Reads a single `Team` using its globally unique `ID`."""
  teamByNodeId(
    """The globally unique `ID` to be used in selecting a single `Team`."""
    nodeId: ID!
  ): Team
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `CircuitDescription` values."""
type CircuitDescriptionsConnection {
  """A list of `CircuitDescription` objects."""
  nodes: [CircuitDescription!]!

  """
  A list of edges which contains the `CircuitDescription` and cursor to aid in pagination.
  """
  edges: [CircuitDescriptionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CircuitDescription` you could get from the connection.
  """
  totalCount: Int!
}

type CircuitDescription implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  circuitId: Int!
  description: String

  """Reads a single `Circuit` that is related to this `CircuitDescription`."""
  circuit: Circuit
}

type Circuit implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  circuitId: Int!
  circuitRef: String
  name: String
  location: String
  country: String
  lat: Float
  lng: Float
  alt: Int
  url: String

  """Reads a single `CircuitDescription` that is related to this `Circuit`."""
  circuitDescription: CircuitDescription

  """Reads and enables pagination through a set of `Race`."""
  racesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RaceCondition
  ): RacesConnection!

  """Reads and enables pagination through a set of `Race`."""
  races(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RaceCondition
  ): [Race!]!
}

"""A connection to a list of `Race` values."""
type RacesConnection {
  """A list of `Race` objects."""
  nodes: [Race!]!

  """
  A list of edges which contains the `Race` and cursor to aid in pagination.
  """
  edges: [RacesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Race` you could get from the connection."""
  totalCount: Int!
}

type Race implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  raceId: Int!
  year: Int
  round: Int
  circuitId: Int
  name: String
  date: Date
  time: String
  url: String
  fp1Date: Date
  fp1Time: String
  fp2Date: Date
  fp2Time: String
  fp3Date: Date
  fp3Time: String
  qualiDate: Date
  qualiTime: String
  sprintDate: Date
  sprintTime: String

  """Reads a single `Season` that is related to this `Race`."""
  seasonByYear: Season

  """Reads a single `Circuit` that is related to this `Race`."""
  circuit: Circuit

  """Reads and enables pagination through a set of `TeamResult`."""
  teamResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamResultCondition
  ): TeamResultsConnection!

  """Reads and enables pagination through a set of `TeamResult`."""
  teamResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamResultCondition
  ): [TeamResult!]!

  """Reads and enables pagination through a set of `TeamStanding`."""
  teamStandingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamStandingCondition
  ): TeamStandingsConnection!

  """Reads and enables pagination through a set of `TeamStanding`."""
  teamStandings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamStandingCondition
  ): [TeamStanding!]!

  """Reads and enables pagination through a set of `DriverStanding`."""
  driverStandingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingCondition
  ): DriverStandingsConnection!

  """Reads and enables pagination through a set of `DriverStanding`."""
  driverStandings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingCondition
  ): [DriverStanding!]!

  """Reads and enables pagination through a set of `LapTime`."""
  lapTimesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimeCondition
  ): LapTimesConnection!

  """Reads and enables pagination through a set of `LapTime`."""
  lapTimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimeCondition
  ): [LapTime!]!

  """Reads and enables pagination through a set of `PitStop`."""
  pitStopsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PitStopCondition
  ): PitStopsConnection!

  """Reads and enables pagination through a set of `PitStop`."""
  pitStops(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PitStopCondition
  ): [PitStop!]!

  """Reads and enables pagination through a set of `Qualifying`."""
  qualifyingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): QualifyingsConnection!

  """Reads and enables pagination through a set of `Qualifying`."""
  qualifyings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): [Qualifying!]!

  """Reads and enables pagination through a set of `Result`."""
  resultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): ResultsConnection!

  """Reads and enables pagination through a set of `Result`."""
  results(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): [Result!]!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): SprintResultsConnection!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): [SprintResult!]!

  """
  Reads and enables pagination through a set of `DriverStandingsBySeason`.
  """
  driverStandingsBySeasonsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): DriverStandingsBySeasonsConnection!

  """
  Reads and enables pagination through a set of `DriverStandingsBySeason`.
  """
  driverStandingsBySeasons(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): [DriverStandingsBySeason!]!

  """
  Reads and enables pagination through a set of `FinalTeamStandingsByYear`.
  """
  finalTeamStandingsByYearsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FinalTeamStandingsByYear`."""
    orderBy: [FinalTeamStandingsByYearsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FinalTeamStandingsByYearCondition
  ): FinalTeamStandingsByYearsConnection!

  """
  Reads and enables pagination through a set of `FinalTeamStandingsByYear`.
  """
  finalTeamStandingsByYears(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `FinalTeamStandingsByYear`."""
    orderBy: [FinalTeamStandingsByYearsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FinalTeamStandingsByYearCondition
  ): [FinalTeamStandingsByYear!]!

  """Reads and enables pagination through a set of `LapTimesWithStart`."""
  lapTimesWithStartsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `LapTimesWithStart`."""
    orderBy: [LapTimesWithStartsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimesWithStartCondition
  ): LapTimesWithStartsConnection!

  """Reads and enables pagination through a set of `LapTimesWithStart`."""
  lapTimesWithStarts(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LapTimesWithStart`."""
    orderBy: [LapTimesWithStartsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimesWithStartCondition
  ): [LapTimesWithStart!]!

  """Reads a single `NextRaceBySeason` that is related to this `Race`."""
  nextRaceBySeason: NextRaceBySeason
  summary: RaceSummary
}

"""The day, does not include a time."""
scalar Date

type Season implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  year: Int!
  url: String

  """Reads and enables pagination through a set of `Race`."""
  racesByYearConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RaceCondition
  ): RacesConnection!

  """Reads and enables pagination through a set of `Race`."""
  racesByYear(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RaceCondition
  ): [Race!]!

  """Reads and enables pagination through a set of `DriverTeam`."""
  driverTeamsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): DriverTeamsConnection!

  """Reads and enables pagination through a set of `DriverTeam`."""
  driverTeams(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): [DriverTeam!]!

  """Reads a single `NextRaceBySeason` that is related to this `Season`."""
  nextRace: NextRaceBySeason
  ended: Boolean
  hasResults: Boolean
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Methods to use when ordering `Race`."""
enum RacesOrderBy {
  NATURAL
  RACE_ID_ASC
  RACE_ID_DESC
  YEAR_ASC
  YEAR_DESC
  ROUND_ASC
  ROUND_DESC
  CIRCUIT_ID_ASC
  CIRCUIT_ID_DESC
  NAME_ASC
  NAME_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  URL_ASC
  URL_DESC
  FP1_DATE_ASC
  FP1_DATE_DESC
  FP1_TIME_ASC
  FP1_TIME_DESC
  FP2_DATE_ASC
  FP2_DATE_DESC
  FP2_TIME_ASC
  FP2_TIME_DESC
  FP3_DATE_ASC
  FP3_DATE_DESC
  FP3_TIME_ASC
  FP3_TIME_DESC
  QUALI_DATE_ASC
  QUALI_DATE_DESC
  QUALI_TIME_ASC
  QUALI_TIME_DESC
  SPRINT_DATE_ASC
  SPRINT_DATE_DESC
  SPRINT_TIME_ASC
  SPRINT_TIME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Race` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RaceCondition {
  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `year` field."""
  year: Int

  """Checks for equality with the object’s `round` field."""
  round: Int

  """Checks for equality with the object’s `circuitId` field."""
  circuitId: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `date` field."""
  date: Date

  """Checks for equality with the object’s `time` field."""
  time: String

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `fp1Date` field."""
  fp1Date: Date

  """Checks for equality with the object’s `fp1Time` field."""
  fp1Time: String

  """Checks for equality with the object’s `fp2Date` field."""
  fp2Date: Date

  """Checks for equality with the object’s `fp2Time` field."""
  fp2Time: String

  """Checks for equality with the object’s `fp3Date` field."""
  fp3Date: Date

  """Checks for equality with the object’s `fp3Time` field."""
  fp3Time: String

  """Checks for equality with the object’s `qualiDate` field."""
  qualiDate: Date

  """Checks for equality with the object’s `qualiTime` field."""
  qualiTime: String

  """Checks for equality with the object’s `sprintDate` field."""
  sprintDate: Date

  """Checks for equality with the object’s `sprintTime` field."""
  sprintTime: String
}

"""A connection to a list of `DriverTeam` values."""
type DriverTeamsConnection {
  """A list of `DriverTeam` objects."""
  nodes: [DriverTeam!]!

  """
  A list of edges which contains the `DriverTeam` and cursor to aid in pagination.
  """
  edges: [DriverTeamsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `DriverTeam` you could get from the connection."""
  totalCount: Int!
}

type DriverTeam {
  driverId: Int
  teamId: Int
  year: Int

  """Reads a single `Driver` that is related to this `DriverTeam`."""
  driver: Driver

  """Reads a single `Team` that is related to this `DriverTeam`."""
  team: Team

  """Reads a single `Season` that is related to this `DriverTeam`."""
  seasonByYear: Season

  """
  Reads and enables pagination through a set of `DriverStandingsBySeason`.
  """
  driverStandingsBySeasonsByDriverIdAndYearConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): DriverStandingsBySeasonsConnection!

  """
  Reads and enables pagination through a set of `DriverStandingsBySeason`.
  """
  driverStandingsBySeasonsByDriverIdAndYear(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): [DriverStandingsBySeason!]!
}

type Driver implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  driverId: Int!
  driverRef: String!
  number: Int
  code: String
  forename: String
  surname: String
  dob: Date
  nationality: String
  url: String

  """Reads and enables pagination through a set of `DriverStanding`."""
  driverStandingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingCondition
  ): DriverStandingsConnection!

  """Reads and enables pagination through a set of `DriverStanding`."""
  driverStandings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingCondition
  ): [DriverStanding!]!

  """Reads and enables pagination through a set of `LapTime`."""
  lapTimesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimeCondition
  ): LapTimesConnection!

  """Reads and enables pagination through a set of `LapTime`."""
  lapTimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LapTimeCondition
  ): [LapTime!]!

  """Reads and enables pagination through a set of `PitStop`."""
  pitStopsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PitStopCondition
  ): PitStopsConnection!

  """Reads and enables pagination through a set of `PitStop`."""
  pitStops(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PitStopCondition
  ): [PitStop!]!

  """Reads and enables pagination through a set of `Qualifying`."""
  qualifyingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): QualifyingsConnection!

  """Reads and enables pagination through a set of `Qualifying`."""
  qualifyings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): [Qualifying!]!

  """Reads and enables pagination through a set of `Result`."""
  resultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): ResultsConnection!

  """Reads and enables pagination through a set of `Result`."""
  results(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): [Result!]!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): SprintResultsConnection!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): [SprintResult!]!

  """Reads a single `DriverCurrentTeam` that is related to this `Driver`."""
  currentTeam: DriverCurrentTeam

  """
  Reads and enables pagination through a set of `DriverStandingsBySeason`.
  """
  driverStandingsBySeasonsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): DriverStandingsBySeasonsConnection!

  """
  Reads and enables pagination through a set of `DriverStandingsBySeason`.
  """
  driverStandingsBySeasons(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverStandingsBySeason`."""
    orderBy: [DriverStandingsBySeasonsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverStandingsBySeasonCondition
  ): [DriverStandingsBySeason!]!

  """Reads and enables pagination through a set of `DriverTeam`."""
  teamsByYearConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): DriverTeamsConnection!

  """Reads and enables pagination through a set of `DriverTeam`."""
  teamsByYear(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): [DriverTeam!]!
  bio: DriverBio
  fullName: String
}

"""A connection to a list of `DriverStanding` values."""
type DriverStandingsConnection {
  """A list of `DriverStanding` objects."""
  nodes: [DriverStanding!]!

  """
  A list of edges which contains the `DriverStanding` and cursor to aid in pagination.
  """
  edges: [DriverStandingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `DriverStanding` you could get from the connection."""
  totalCount: Int!
}

type DriverStanding implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  driverStandingsId: Int!
  raceId: Int
  driverId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int

  """Reads a single `Race` that is related to this `DriverStanding`."""
  race: Race

  """Reads a single `Driver` that is related to this `DriverStanding`."""
  driver: Driver
}

"""A `DriverStanding` edge in the connection."""
type DriverStandingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DriverStanding` at the end of the edge."""
  node: DriverStanding!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `DriverStanding`."""
enum DriverStandingsOrderBy {
  NATURAL
  DRIVER_STANDINGS_ID_ASC
  DRIVER_STANDINGS_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  POINTS_ASC
  POINTS_DESC
  POSITION_ASC
  POSITION_DESC
  POSITION_TEXT_ASC
  POSITION_TEXT_DESC
  WINS_ASC
  WINS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `DriverStanding` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input DriverStandingCondition {
  """Checks for equality with the object’s `driverStandingsId` field."""
  driverStandingsId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `points` field."""
  points: Float

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `positionText` field."""
  positionText: String

  """Checks for equality with the object’s `wins` field."""
  wins: Int

  """Filters driverStandings by year"""
  year: Int
}

"""A connection to a list of `LapTime` values."""
type LapTimesConnection {
  """A list of `LapTime` objects."""
  nodes: [LapTime!]!

  """
  A list of edges which contains the `LapTime` and cursor to aid in pagination.
  """
  edges: [LapTimesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `LapTime` you could get from the connection."""
  totalCount: Int!
}

type LapTime implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  raceId: Int!
  driverId: Int!
  lap: Int!
  position: Int
  time: String
  milliseconds: Int

  """Reads a single `Race` that is related to this `LapTime`."""
  race: Race

  """Reads a single `Driver` that is related to this `LapTime`."""
  driver: Driver
}

"""A `LapTime` edge in the connection."""
type LapTimesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `LapTime` at the end of the edge."""
  node: LapTime!
}

"""Methods to use when ordering `LapTime`."""
enum LapTimesOrderBy {
  NATURAL
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  LAP_ASC
  LAP_DESC
  POSITION_ASC
  POSITION_DESC
  TIME_ASC
  TIME_DESC
  MILLISECONDS_ASC
  MILLISECONDS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LapTime` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input LapTimeCondition {
  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `lap` field."""
  lap: Int

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `time` field."""
  time: String

  """Checks for equality with the object’s `milliseconds` field."""
  milliseconds: Int
}

"""A connection to a list of `PitStop` values."""
type PitStopsConnection {
  """A list of `PitStop` objects."""
  nodes: [PitStop!]!

  """
  A list of edges which contains the `PitStop` and cursor to aid in pagination.
  """
  edges: [PitStopsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PitStop` you could get from the connection."""
  totalCount: Int!
}

type PitStop implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  raceId: Int!
  driverId: Int!
  stop: Int!
  lap: Int
  time: String
  duration: String
  milliseconds: Int

  """Reads a single `Race` that is related to this `PitStop`."""
  race: Race

  """Reads a single `Driver` that is related to this `PitStop`."""
  driver: Driver
}

"""A `PitStop` edge in the connection."""
type PitStopsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PitStop` at the end of the edge."""
  node: PitStop!
}

"""Methods to use when ordering `PitStop`."""
enum PitStopsOrderBy {
  NATURAL
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  STOP_ASC
  STOP_DESC
  LAP_ASC
  LAP_DESC
  TIME_ASC
  TIME_DESC
  DURATION_ASC
  DURATION_DESC
  MILLISECONDS_ASC
  MILLISECONDS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PitStop` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PitStopCondition {
  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `stop` field."""
  stop: Int

  """Checks for equality with the object’s `lap` field."""
  lap: Int

  """Checks for equality with the object’s `time` field."""
  time: String

  """Checks for equality with the object’s `duration` field."""
  duration: String

  """Checks for equality with the object’s `milliseconds` field."""
  milliseconds: Int
}

"""A connection to a list of `Qualifying` values."""
type QualifyingsConnection {
  """A list of `Qualifying` objects."""
  nodes: [Qualifying!]!

  """
  A list of edges which contains the `Qualifying` and cursor to aid in pagination.
  """
  edges: [QualifyingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Qualifying` you could get from the connection."""
  totalCount: Int!
}

type Qualifying implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  qualifyId: Int!
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  position: Int
  q1: String
  q2: String
  q3: String

  """Reads a single `Race` that is related to this `Qualifying`."""
  race: Race

  """Reads a single `Driver` that is related to this `Qualifying`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Qualifying`."""
  team: Team
}

type Team implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  teamId: Int!
  constructorRef: String
  name: String
  nationality: String
  url: String

  """Reads and enables pagination through a set of `TeamResult`."""
  teamResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamResultCondition
  ): TeamResultsConnection!

  """Reads and enables pagination through a set of `TeamResult`."""
  teamResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamResultCondition
  ): [TeamResult!]!

  """Reads and enables pagination through a set of `TeamStanding`."""
  teamStandingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamStandingCondition
  ): TeamStandingsConnection!

  """Reads and enables pagination through a set of `TeamStanding`."""
  teamStandings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamStandingCondition
  ): [TeamStanding!]!

  """Reads and enables pagination through a set of `Qualifying`."""
  qualifyingsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): QualifyingsConnection!

  """Reads and enables pagination through a set of `Qualifying`."""
  qualifyings(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QualifyingCondition
  ): [Qualifying!]!

  """Reads and enables pagination through a set of `Result`."""
  resultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): ResultsConnection!

  """Reads and enables pagination through a set of `Result`."""
  results(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): [Result!]!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): SprintResultsConnection!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): [SprintResult!]!

  """Reads a single `TeamColor` that is related to this `Team`."""
  colors: TeamColor

  """Reads and enables pagination through a set of `TeamHistory`."""
  teamHistoriesConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamHistoryCondition
  ): TeamHistoriesConnection!

  """Reads and enables pagination through a set of `TeamHistory`."""
  teamHistories(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamHistoryCondition
  ): [TeamHistory!]!

  """Reads and enables pagination through a set of `TeamHistory`."""
  teamHistoriesByAntecedentTeamIdConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamHistoryCondition
  ): TeamHistoriesConnection!

  """Reads and enables pagination through a set of `TeamHistory`."""
  teamHistoriesByAntecedentTeamId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamHistoryCondition
  ): [TeamHistory!]!

  """Reads and enables pagination through a set of `DriverCurrentTeam`."""
  currentDriversConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverCurrentTeam`."""
    orderBy: [DriverCurrentTeamsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverCurrentTeamCondition
  ): DriverCurrentTeamsConnection!

  """Reads and enables pagination through a set of `DriverCurrentTeam`."""
  currentDrivers(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverCurrentTeam`."""
    orderBy: [DriverCurrentTeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverCurrentTeamCondition
  ): [DriverCurrentTeam!]!

  """Reads and enables pagination through a set of `DriverTeam`."""
  driversByYearConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): DriverTeamsConnection!

  """Reads and enables pagination through a set of `DriverTeam`."""
  driversByYear(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `DriverTeam`."""
    orderBy: [DriverTeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DriverTeamCondition
  ): [DriverTeam!]!

  """
  Reads and enables pagination through a set of `FinalTeamStandingsByYear`.
  """
  finalTeamStandingsByYearsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FinalTeamStandingsByYear`."""
    orderBy: [FinalTeamStandingsByYearsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FinalTeamStandingsByYearCondition
  ): FinalTeamStandingsByYearsConnection!

  """
  Reads and enables pagination through a set of `FinalTeamStandingsByYear`.
  """
  finalTeamStandingsByYears(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `FinalTeamStandingsByYear`."""
    orderBy: [FinalTeamStandingsByYearsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FinalTeamStandingsByYearCondition
  ): [FinalTeamStandingsByYear!]!
  bio: TeamBio
}

"""A connection to a list of `TeamResult` values."""
type TeamResultsConnection {
  """A list of `TeamResult` objects."""
  nodes: [TeamResult!]!

  """
  A list of edges which contains the `TeamResult` and cursor to aid in pagination.
  """
  edges: [TeamResultsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TeamResult` you could get from the connection."""
  totalCount: Int!
}

type TeamResult implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  constructorResultsId: Int!
  raceId: Int
  teamId: Int
  points: Float
  status: String

  """Reads a single `Race` that is related to this `TeamResult`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamResult`."""
  team: Team
}

"""A `TeamResult` edge in the connection."""
type TeamResultsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TeamResult` at the end of the edge."""
  node: TeamResult!
}

"""Methods to use when ordering `TeamResult`."""
enum TeamResultsOrderBy {
  NATURAL
  CONSTRUCTOR_RESULTS_ID_ASC
  CONSTRUCTOR_RESULTS_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  POINTS_ASC
  POINTS_DESC
  STATUS_ASC
  STATUS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TeamResult` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TeamResultCondition {
  """Checks for equality with the object’s `constructorResultsId` field."""
  constructorResultsId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `points` field."""
  points: Float

  """Checks for equality with the object’s `status` field."""
  status: String
}

"""A connection to a list of `TeamStanding` values."""
type TeamStandingsConnection {
  """A list of `TeamStanding` objects."""
  nodes: [TeamStanding!]!

  """
  A list of edges which contains the `TeamStanding` and cursor to aid in pagination.
  """
  edges: [TeamStandingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TeamStanding` you could get from the connection."""
  totalCount: Int!
}

type TeamStanding implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  constructorStandingsId: Int!
  raceId: Int
  teamId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int

  """Reads a single `Race` that is related to this `TeamStanding`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamStanding`."""
  team: Team
}

"""A `TeamStanding` edge in the connection."""
type TeamStandingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TeamStanding` at the end of the edge."""
  node: TeamStanding!
}

"""Methods to use when ordering `TeamStanding`."""
enum TeamStandingsOrderBy {
  NATURAL
  CONSTRUCTOR_STANDINGS_ID_ASC
  CONSTRUCTOR_STANDINGS_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  POINTS_ASC
  POINTS_DESC
  POSITION_ASC
  POSITION_DESC
  POSITION_TEXT_ASC
  POSITION_TEXT_DESC
  WINS_ASC
  WINS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TeamStanding` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TeamStandingCondition {
  """Checks for equality with the object’s `constructorStandingsId` field."""
  constructorStandingsId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `points` field."""
  points: Float

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `positionText` field."""
  positionText: String

  """Checks for equality with the object’s `wins` field."""
  wins: Int

  """Filters teamStandings by year"""
  year: Int
}

"""Methods to use when ordering `Qualifying`."""
enum QualifyingsOrderBy {
  NATURAL
  QUALIFY_ID_ASC
  QUALIFY_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  NUMBER_ASC
  NUMBER_DESC
  POSITION_ASC
  POSITION_DESC
  Q1_ASC
  Q1_DESC
  Q2_ASC
  Q2_DESC
  Q3_ASC
  Q3_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Qualifying` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input QualifyingCondition {
  """Checks for equality with the object’s `qualifyId` field."""
  qualifyId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `number` field."""
  number: Int

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `q1` field."""
  q1: String

  """Checks for equality with the object’s `q2` field."""
  q2: String

  """Checks for equality with the object’s `q3` field."""
  q3: String
}

"""A connection to a list of `Result` values."""
type ResultsConnection {
  """A list of `Result` objects."""
  nodes: [Result!]!

  """
  A list of edges which contains the `Result` and cursor to aid in pagination.
  """
  edges: [ResultsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Result` you could get from the connection."""
  totalCount: Int!
}

type Result implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  resultId: Int!
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  grid: Int
  position: Int
  positionText: String
  positionOrder: Int
  points: Float
  laps: Int
  time: String
  milliseconds: Int
  fastestLap: Int
  rank: Int
  fastestLapTime: String
  fastestLapSpeed: String
  statusId: Int

  """Reads a single `Race` that is related to this `Result`."""
  race: Race

  """Reads a single `Driver` that is related to this `Result`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Result`."""
  team: Team

  """Reads a single `Status` that is related to this `Result`."""
  status: Status
}

type Status implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  statusId: Int!
  status: String

  """Reads and enables pagination through a set of `Result`."""
  resultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): ResultsConnection!

  """Reads and enables pagination through a set of `Result`."""
  results(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ResultCondition
  ): [Result!]!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResultsConnection(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): SprintResultsConnection!

  """Reads and enables pagination through a set of `SprintResult`."""
  sprintResults(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SprintResultCondition
  ): [SprintResult!]!
}

"""Methods to use when ordering `Result`."""
enum ResultsOrderBy {
  NATURAL
  RESULT_ID_ASC
  RESULT_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  NUMBER_ASC
  NUMBER_DESC
  GRID_ASC
  GRID_DESC
  POSITION_ASC
  POSITION_DESC
  POSITION_TEXT_ASC
  POSITION_TEXT_DESC
  POSITION_ORDER_ASC
  POSITION_ORDER_DESC
  POINTS_ASC
  POINTS_DESC
  LAPS_ASC
  LAPS_DESC
  TIME_ASC
  TIME_DESC
  MILLISECONDS_ASC
  MILLISECONDS_DESC
  FASTEST_LAP_ASC
  FASTEST_LAP_DESC
  RANK_ASC
  RANK_DESC
  FASTEST_LAP_TIME_ASC
  FASTEST_LAP_TIME_DESC
  FASTEST_LAP_SPEED_ASC
  FASTEST_LAP_SPEED_DESC
  STATUS_ID_ASC
  STATUS_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Result` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ResultCondition {
  """Checks for equality with the object’s `resultId` field."""
  resultId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `number` field."""
  number: Int

  """Checks for equality with the object’s `grid` field."""
  grid: Int

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `positionText` field."""
  positionText: String

  """Checks for equality with the object’s `positionOrder` field."""
  positionOrder: Int

  """Checks for equality with the object’s `points` field."""
  points: Float

  """Checks for equality with the object’s `laps` field."""
  laps: Int

  """Checks for equality with the object’s `time` field."""
  time: String

  """Checks for equality with the object’s `milliseconds` field."""
  milliseconds: Int

  """Checks for equality with the object’s `fastestLap` field."""
  fastestLap: Int

  """Checks for equality with the object’s `rank` field."""
  rank: Int

  """Checks for equality with the object’s `fastestLapTime` field."""
  fastestLapTime: String

  """Checks for equality with the object’s `fastestLapSpeed` field."""
  fastestLapSpeed: String

  """Checks for equality with the object’s `statusId` field."""
  statusId: Int

  """Filters results by year"""
  year: Int
}

"""A connection to a list of `SprintResult` values."""
type SprintResultsConnection {
  """A list of `SprintResult` objects."""
  nodes: [SprintResult!]!

  """
  A list of edges which contains the `SprintResult` and cursor to aid in pagination.
  """
  edges: [SprintResultsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SprintResult` you could get from the connection."""
  totalCount: Int!
}

type SprintResult implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  sprintResultId: Int!
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  grid: Int
  position: Int
  positionText: String
  positionOrder: Int
  points: Float
  laps: Int
  time: String
  milliseconds: Int
  fastestLap: Int
  fastestLapTime: String
  statusId: Int

  """Reads a single `Race` that is related to this `SprintResult`."""
  race: Race

  """Reads a single `Driver` that is related to this `SprintResult`."""
  driver: Driver

  """Reads a single `Team` that is related to this `SprintResult`."""
  team: Team

  """Reads a single `Status` that is related to this `SprintResult`."""
  status: Status
}

"""A `SprintResult` edge in the connection."""
type SprintResultsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SprintResult` at the end of the edge."""
  node: SprintResult!
}

"""Methods to use when ordering `SprintResult`."""
enum SprintResultsOrderBy {
  NATURAL
  SPRINT_RESULT_ID_ASC
  SPRINT_RESULT_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  NUMBER_ASC
  NUMBER_DESC
  GRID_ASC
  GRID_DESC
  POSITION_ASC
  POSITION_DESC
  POSITION_TEXT_ASC
  POSITION_TEXT_DESC
  POSITION_ORDER_ASC
  POSITION_ORDER_DESC
  POINTS_ASC
  POINTS_DESC
  LAPS_ASC
  LAPS_DESC
  TIME_ASC
  TIME_DESC
  MILLISECONDS_ASC
  MILLISECONDS_DESC
  FASTEST_LAP_ASC
  FASTEST_LAP_DESC
  FASTEST_LAP_TIME_ASC
  FASTEST_LAP_TIME_DESC
  STATUS_ID_ASC
  STATUS_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `SprintResult` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SprintResultCondition {
  """Checks for equality with the object’s `sprintResultId` field."""
  sprintResultId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `number` field."""
  number: Int

  """Checks for equality with the object’s `grid` field."""
  grid: Int

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `positionText` field."""
  positionText: String

  """Checks for equality with the object’s `positionOrder` field."""
  positionOrder: Int

  """Checks for equality with the object’s `points` field."""
  points: Float

  """Checks for equality with the object’s `laps` field."""
  laps: Int

  """Checks for equality with the object’s `time` field."""
  time: String

  """Checks for equality with the object’s `milliseconds` field."""
  milliseconds: Int

  """Checks for equality with the object’s `fastestLap` field."""
  fastestLap: Int

  """Checks for equality with the object’s `fastestLapTime` field."""
  fastestLapTime: String

  """Checks for equality with the object’s `statusId` field."""
  statusId: Int

  """Filters sprintResults by year"""
  year: Int
}

"""A `Result` edge in the connection."""
type ResultsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Result` at the end of the edge."""
  node: Result!
}

type TeamColor implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  teamId: Int!
  primary: String
  secondary: String
  logo: String

  """Reads a single `Team` that is related to this `TeamColor`."""
  team: Team
}

"""A connection to a list of `TeamHistory` values."""
type TeamHistoriesConnection {
  """A list of `TeamHistory` objects."""
  nodes: [TeamHistory!]!

  """
  A list of edges which contains the `TeamHistory` and cursor to aid in pagination.
  """
  edges: [TeamHistoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TeamHistory` you could get from the connection."""
  totalCount: Int!
}

type TeamHistory implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  teamId: Int!
  antecedentTeamId: Int!
  startYear: Int!
  endYear: Int

  """Reads a single `Team` that is related to this `TeamHistory`."""
  team: Team

  """Reads a single `Team` that is related to this `TeamHistory`."""
  antecedentTeam: Team
}

"""A `TeamHistory` edge in the connection."""
type TeamHistoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TeamHistory` at the end of the edge."""
  node: TeamHistory!
}

"""Methods to use when ordering `TeamHistory`."""
enum TeamHistoriesOrderBy {
  NATURAL
  TEAM_ID_ASC
  TEAM_ID_DESC
  ANTECEDENT_TEAM_ID_ASC
  ANTECEDENT_TEAM_ID_DESC
  START_YEAR_ASC
  START_YEAR_DESC
  END_YEAR_ASC
  END_YEAR_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TeamHistory` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TeamHistoryCondition {
  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `antecedentTeamId` field."""
  antecedentTeamId: Int

  """Checks for equality with the object’s `startYear` field."""
  startYear: Int

  """Checks for equality with the object’s `endYear` field."""
  endYear: Int
}

"""A connection to a list of `DriverCurrentTeam` values."""
type DriverCurrentTeamsConnection {
  """A list of `DriverCurrentTeam` objects."""
  nodes: [DriverCurrentTeam!]!

  """
  A list of edges which contains the `DriverCurrentTeam` and cursor to aid in pagination.
  """
  edges: [DriverCurrentTeamsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `DriverCurrentTeam` you could get from the connection.
  """
  totalCount: Int!
}

type DriverCurrentTeam {
  driverId: Int
  teamId: Int
  year: Int

  """Reads a single `Driver` that is related to this `DriverCurrentTeam`."""
  driver: Driver

  """Reads a single `Team` that is related to this `DriverCurrentTeam`."""
  team: Team
}

"""A `DriverCurrentTeam` edge in the connection."""
type DriverCurrentTeamsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DriverCurrentTeam` at the end of the edge."""
  node: DriverCurrentTeam!
}

"""Methods to use when ordering `DriverCurrentTeam`."""
enum DriverCurrentTeamsOrderBy {
  NATURAL
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  YEAR_ASC
  YEAR_DESC
}

"""
A condition to be used against `DriverCurrentTeam` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input DriverCurrentTeamCondition {
  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `year` field."""
  year: Int
}

"""Methods to use when ordering `DriverTeam`."""
enum DriverTeamsOrderBy {
  NATURAL
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  YEAR_ASC
  YEAR_DESC
}

"""
A condition to be used against `DriverTeam` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DriverTeamCondition {
  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `year` field."""
  year: Int
}

"""A connection to a list of `FinalTeamStandingsByYear` values."""
type FinalTeamStandingsByYearsConnection {
  """A list of `FinalTeamStandingsByYear` objects."""
  nodes: [FinalTeamStandingsByYear!]!

  """
  A list of edges which contains the `FinalTeamStandingsByYear` and cursor to aid in pagination.
  """
  edges: [FinalTeamStandingsByYearsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `FinalTeamStandingsByYear` you could get from the connection.
  """
  totalCount: Int!
}

type FinalTeamStandingsByYear {
  constructorStandingsId: Int
  raceId: Int
  teamId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int
  year: Int

  """
  Reads a single `Team` that is related to this `FinalTeamStandingsByYear`.
  """
  team: Team

  """
  Reads a single `Race` that is related to this `FinalTeamStandingsByYear`.
  """
  race: Race
}

"""A `FinalTeamStandingsByYear` edge in the connection."""
type FinalTeamStandingsByYearsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `FinalTeamStandingsByYear` at the end of the edge."""
  node: FinalTeamStandingsByYear!
}

"""Methods to use when ordering `FinalTeamStandingsByYear`."""
enum FinalTeamStandingsByYearsOrderBy {
  NATURAL
  CONSTRUCTOR_STANDINGS_ID_ASC
  CONSTRUCTOR_STANDINGS_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  POINTS_ASC
  POINTS_DESC
  POSITION_ASC
  POSITION_DESC
  POSITION_TEXT_ASC
  POSITION_TEXT_DESC
  WINS_ASC
  WINS_DESC
  YEAR_ASC
  YEAR_DESC
}

"""
A condition to be used against `FinalTeamStandingsByYear` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input FinalTeamStandingsByYearCondition {
  """Checks for equality with the object’s `constructorStandingsId` field."""
  constructorStandingsId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `points` field."""
  points: Float

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `positionText` field."""
  positionText: String

  """Checks for equality with the object’s `wins` field."""
  wins: Int

  """Checks for equality with the object’s `year` field."""
  year: Int
}

type TeamBio {
  title: String
  thumbnail: TeamBioImage
  description: String
  extract: String
}

type TeamBioImage {
  source: String
  width: Int
  height: Int
}

"""A `Qualifying` edge in the connection."""
type QualifyingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Qualifying` at the end of the edge."""
  node: Qualifying!
}

"""A connection to a list of `DriverStandingsBySeason` values."""
type DriverStandingsBySeasonsConnection {
  """A list of `DriverStandingsBySeason` objects."""
  nodes: [DriverStandingsBySeason!]!

  """
  A list of edges which contains the `DriverStandingsBySeason` and cursor to aid in pagination.
  """
  edges: [DriverStandingsBySeasonsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `DriverStandingsBySeason` you could get from the connection.
  """
  totalCount: Int!
}

type DriverStandingsBySeason {
  driverStandingsId: Int
  raceId: Int
  driverId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int
  year: Int

  """
  Reads a single `Driver` that is related to this `DriverStandingsBySeason`.
  """
  driver: Driver

  """
  Reads a single `Race` that is related to this `DriverStandingsBySeason`.
  """
  race: Race

  """
  Reads a single `DriverTeam` that is related to this `DriverStandingsBySeason`.
  """
  driverTeamByDriverIdAndYear: DriverTeam
}

"""A `DriverStandingsBySeason` edge in the connection."""
type DriverStandingsBySeasonsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DriverStandingsBySeason` at the end of the edge."""
  node: DriverStandingsBySeason!
}

"""Methods to use when ordering `DriverStandingsBySeason`."""
enum DriverStandingsBySeasonsOrderBy {
  NATURAL
  DRIVER_STANDINGS_ID_ASC
  DRIVER_STANDINGS_ID_DESC
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  POINTS_ASC
  POINTS_DESC
  POSITION_ASC
  POSITION_DESC
  POSITION_TEXT_ASC
  POSITION_TEXT_DESC
  WINS_ASC
  WINS_DESC
  YEAR_ASC
  YEAR_DESC
}

"""
A condition to be used against `DriverStandingsBySeason` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input DriverStandingsBySeasonCondition {
  """Checks for equality with the object’s `driverStandingsId` field."""
  driverStandingsId: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `points` field."""
  points: Float

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `positionText` field."""
  positionText: String

  """Checks for equality with the object’s `wins` field."""
  wins: Int

  """Checks for equality with the object’s `year` field."""
  year: Int
}

type DriverBio {
  title: String
  thumbnail: BioImage
  description: String
  extract: String
}

type BioImage {
  source: String
  width: Int
  height: Int
}

"""A `DriverTeam` edge in the connection."""
type DriverTeamsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DriverTeam` at the end of the edge."""
  node: DriverTeam!
}

type NextRaceBySeason {
  year: Int
  raceId: Int

  """Reads a single `Season` that is related to this `NextRaceBySeason`."""
  season: Season

  """Reads a single `Race` that is related to this `NextRaceBySeason`."""
  race: Race
}

"""A connection to a list of `LapTimesWithStart` values."""
type LapTimesWithStartsConnection {
  """A list of `LapTimesWithStart` objects."""
  nodes: [LapTimesWithStart!]!

  """
  A list of edges which contains the `LapTimesWithStart` and cursor to aid in pagination.
  """
  edges: [LapTimesWithStartsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `LapTimesWithStart` you could get from the connection.
  """
  totalCount: Int!
}

type LapTimesWithStart {
  raceId: Int
  driverId: Int
  lap: Int
  position: Int
  time: String
  milliseconds: Int

  """Reads a single `Race` that is related to this `LapTimesWithStart`."""
  race: Race
}

"""A `LapTimesWithStart` edge in the connection."""
type LapTimesWithStartsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `LapTimesWithStart` at the end of the edge."""
  node: LapTimesWithStart!
}

"""Methods to use when ordering `LapTimesWithStart`."""
enum LapTimesWithStartsOrderBy {
  NATURAL
  RACE_ID_ASC
  RACE_ID_DESC
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  LAP_ASC
  LAP_DESC
  POSITION_ASC
  POSITION_DESC
  TIME_ASC
  TIME_DESC
  MILLISECONDS_ASC
  MILLISECONDS_DESC
}

"""
A condition to be used against `LapTimesWithStart` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input LapTimesWithStartCondition {
  """Checks for equality with the object’s `raceId` field."""
  raceId: Int

  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `lap` field."""
  lap: Int

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `time` field."""
  time: String

  """Checks for equality with the object’s `milliseconds` field."""
  milliseconds: Int
}

type RaceSummary {
  title: String
  description: String
  extract: String
}

"""A `Race` edge in the connection."""
type RacesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Race` at the end of the edge."""
  node: Race!
}

"""A `CircuitDescription` edge in the connection."""
type CircuitDescriptionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CircuitDescription` at the end of the edge."""
  node: CircuitDescription!
}

"""Methods to use when ordering `CircuitDescription`."""
enum CircuitDescriptionsOrderBy {
  NATURAL
  CIRCUIT_ID_ASC
  CIRCUIT_ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CircuitDescription` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CircuitDescriptionCondition {
  """Checks for equality with the object’s `circuitId` field."""
  circuitId: Int

  """Checks for equality with the object’s `description` field."""
  description: String
}

"""A connection to a list of `Circuit` values."""
type CircuitsConnection {
  """A list of `Circuit` objects."""
  nodes: [Circuit!]!

  """
  A list of edges which contains the `Circuit` and cursor to aid in pagination.
  """
  edges: [CircuitsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Circuit` you could get from the connection."""
  totalCount: Int!
}

"""A `Circuit` edge in the connection."""
type CircuitsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Circuit` at the end of the edge."""
  node: Circuit!
}

"""Methods to use when ordering `Circuit`."""
enum CircuitsOrderBy {
  NATURAL
  CIRCUIT_ID_ASC
  CIRCUIT_ID_DESC
  CIRCUIT_REF_ASC
  CIRCUIT_REF_DESC
  NAME_ASC
  NAME_DESC
  LOCATION_ASC
  LOCATION_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  LAT_ASC
  LAT_DESC
  LNG_ASC
  LNG_DESC
  ALT_ASC
  ALT_DESC
  URL_ASC
  URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Circuit` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CircuitCondition {
  """Checks for equality with the object’s `circuitId` field."""
  circuitId: Int

  """Checks for equality with the object’s `circuitRef` field."""
  circuitRef: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `location` field."""
  location: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `lat` field."""
  lat: Float

  """Checks for equality with the object’s `lng` field."""
  lng: Float

  """Checks for equality with the object’s `alt` field."""
  alt: Int

  """Checks for equality with the object’s `url` field."""
  url: String
}

"""A connection to a list of `Driver` values."""
type DriversConnection {
  """A list of `Driver` objects."""
  nodes: [Driver!]!

  """
  A list of edges which contains the `Driver` and cursor to aid in pagination.
  """
  edges: [DriversEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Driver` you could get from the connection."""
  totalCount: Int!
}

"""A `Driver` edge in the connection."""
type DriversEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Driver` at the end of the edge."""
  node: Driver!
}

"""Methods to use when ordering `Driver`."""
enum DriversOrderBy {
  NATURAL
  DRIVER_ID_ASC
  DRIVER_ID_DESC
  DRIVER_REF_ASC
  DRIVER_REF_DESC
  NUMBER_ASC
  NUMBER_DESC
  CODE_ASC
  CODE_DESC
  FORENAME_ASC
  FORENAME_DESC
  SURNAME_ASC
  SURNAME_DESC
  DOB_ASC
  DOB_DESC
  NATIONALITY_ASC
  NATIONALITY_DESC
  URL_ASC
  URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Driver` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input DriverCondition {
  """Checks for equality with the object’s `driverId` field."""
  driverId: Int

  """Checks for equality with the object’s `driverRef` field."""
  driverRef: String

  """Checks for equality with the object’s `number` field."""
  number: Int

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `forename` field."""
  forename: String

  """Checks for equality with the object’s `surname` field."""
  surname: String

  """Checks for equality with the object’s `dob` field."""
  dob: Date

  """Checks for equality with the object’s `nationality` field."""
  nationality: String

  """Checks for equality with the object’s `url` field."""
  url: String
}

"""A connection to a list of `NextRaceBySeason` values."""
type NextRaceBySeasonsConnection {
  """A list of `NextRaceBySeason` objects."""
  nodes: [NextRaceBySeason!]!

  """
  A list of edges which contains the `NextRaceBySeason` and cursor to aid in pagination.
  """
  edges: [NextRaceBySeasonsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `NextRaceBySeason` you could get from the connection.
  """
  totalCount: Int!
}

"""A `NextRaceBySeason` edge in the connection."""
type NextRaceBySeasonsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `NextRaceBySeason` at the end of the edge."""
  node: NextRaceBySeason!
}

"""Methods to use when ordering `NextRaceBySeason`."""
enum NextRaceBySeasonsOrderBy {
  NATURAL
  YEAR_ASC
  YEAR_DESC
  RACE_ID_ASC
  RACE_ID_DESC
}

"""
A condition to be used against `NextRaceBySeason` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input NextRaceBySeasonCondition {
  """Checks for equality with the object’s `year` field."""
  year: Int

  """Checks for equality with the object’s `raceId` field."""
  raceId: Int
}

"""A connection to a list of `Season` values."""
type SeasonsConnection {
  """A list of `Season` objects."""
  nodes: [Season!]!

  """
  A list of edges which contains the `Season` and cursor to aid in pagination.
  """
  edges: [SeasonsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Season` you could get from the connection."""
  totalCount: Int!
}

"""A `Season` edge in the connection."""
type SeasonsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Season` at the end of the edge."""
  node: Season!
}

"""Methods to use when ordering `Season`."""
enum SeasonsOrderBy {
  NATURAL
  YEAR_ASC
  YEAR_DESC
  URL_ASC
  URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Season` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SeasonCondition {
  """Checks for equality with the object’s `year` field."""
  year: Int

  """Checks for equality with the object’s `url` field."""
  url: String

  """Filters seasons by 'hasResults'"""
  hasResults: Boolean

  """Filters seasons by 'ended'"""
  ended: Boolean
}

"""A connection to a list of `Status` values."""
type StatusesConnection {
  """A list of `Status` objects."""
  nodes: [Status!]!

  """
  A list of edges which contains the `Status` and cursor to aid in pagination.
  """
  edges: [StatusesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Status` you could get from the connection."""
  totalCount: Int!
}

"""A `Status` edge in the connection."""
type StatusesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Status` at the end of the edge."""
  node: Status!
}

"""Methods to use when ordering `Status`."""
enum StatusesOrderBy {
  NATURAL
  STATUS_ID_ASC
  STATUS_ID_DESC
  STATUS_ASC
  STATUS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Status` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StatusCondition {
  """Checks for equality with the object’s `statusId` field."""
  statusId: Int

  """Checks for equality with the object’s `status` field."""
  status: String
}

"""A connection to a list of `TeamColor` values."""
type TeamColorsConnection {
  """A list of `TeamColor` objects."""
  nodes: [TeamColor!]!

  """
  A list of edges which contains the `TeamColor` and cursor to aid in pagination.
  """
  edges: [TeamColorsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TeamColor` you could get from the connection."""
  totalCount: Int!
}

"""A `TeamColor` edge in the connection."""
type TeamColorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TeamColor` at the end of the edge."""
  node: TeamColor!
}

"""Methods to use when ordering `TeamColor`."""
enum TeamColorsOrderBy {
  NATURAL
  TEAM_ID_ASC
  TEAM_ID_DESC
  PRIMARY_ASC
  PRIMARY_DESC
  SECONDARY_ASC
  SECONDARY_DESC
  LOGO_ASC
  LOGO_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TeamColor` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TeamColorCondition {
  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `primary` field."""
  primary: String

  """Checks for equality with the object’s `secondary` field."""
  secondary: String

  """Checks for equality with the object’s `logo` field."""
  logo: String
}

"""A connection to a list of `Team` values."""
type TeamsConnection {
  """A list of `Team` objects."""
  nodes: [Team!]!

  """
  A list of edges which contains the `Team` and cursor to aid in pagination.
  """
  edges: [TeamsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Team` you could get from the connection."""
  totalCount: Int!
}

"""A `Team` edge in the connection."""
type TeamsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Team` at the end of the edge."""
  node: Team!
}

"""Methods to use when ordering `Team`."""
enum TeamsOrderBy {
  NATURAL
  TEAM_ID_ASC
  TEAM_ID_DESC
  CONSTRUCTOR_REF_ASC
  CONSTRUCTOR_REF_DESC
  NAME_ASC
  NAME_DESC
  NATIONALITY_ASC
  NATIONALITY_DESC
  URL_ASC
  URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TeamCondition {
  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `constructorRef` field."""
  constructorRef: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `nationality` field."""
  nationality: String

  """Checks for equality with the object’s `url` field."""
  url: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `CircuitDescription`."""
  createCircuitDescription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCircuitDescriptionInput!
  ): CreateCircuitDescriptionPayload

  """Creates a single `Circuit`."""
  createCircuit(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCircuitInput!
  ): CreateCircuitPayload

  """Creates a single `DriverStanding`."""
  createDriverStanding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDriverStandingInput!
  ): CreateDriverStandingPayload

  """Creates a single `Driver`."""
  createDriver(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDriverInput!
  ): CreateDriverPayload

  """Creates a single `LapTime`."""
  createLapTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLapTimeInput!
  ): CreateLapTimePayload

  """Creates a single `PitStop`."""
  createPitStop(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePitStopInput!
  ): CreatePitStopPayload

  """Creates a single `Qualifying`."""
  createQualifying(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateQualifyingInput!
  ): CreateQualifyingPayload

  """Creates a single `Race`."""
  createRace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRaceInput!
  ): CreateRacePayload

  """Creates a single `Result`."""
  createResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateResultInput!
  ): CreateResultPayload

  """Creates a single `Season`."""
  createSeason(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSeasonInput!
  ): CreateSeasonPayload

  """Creates a single `SprintResult`."""
  createSprintResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSprintResultInput!
  ): CreateSprintResultPayload

  """Creates a single `Status`."""
  createStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStatusInput!
  ): CreateStatusPayload

  """Creates a single `TeamColor`."""
  createTeamColor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamColorInput!
  ): CreateTeamColorPayload

  """Creates a single `TeamHistory`."""
  createTeamHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamHistoryInput!
  ): CreateTeamHistoryPayload

  """Creates a single `TeamResult`."""
  createTeamResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamResultInput!
  ): CreateTeamResultPayload

  """Creates a single `TeamStanding`."""
  createTeamStanding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamStandingInput!
  ): CreateTeamStandingPayload

  """Creates a single `Team`."""
  createTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamInput!
  ): CreateTeamPayload

  """
  Updates a single `CircuitDescription` using its globally unique id and a patch.
  """
  updateCircuitDescriptionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCircuitDescriptionByNodeIdInput!
  ): UpdateCircuitDescriptionPayload

  """Updates a single `CircuitDescription` using a unique key and a patch."""
  updateCircuitDescription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCircuitDescriptionInput!
  ): UpdateCircuitDescriptionPayload

  """Updates a single `Circuit` using its globally unique id and a patch."""
  updateCircuitByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCircuitByNodeIdInput!
  ): UpdateCircuitPayload

  """Updates a single `Circuit` using a unique key and a patch."""
  updateCircuit(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCircuitInput!
  ): UpdateCircuitPayload

  """Updates a single `Circuit` using a unique key and a patch."""
  updateCircuitByCircuitRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCircuitByCircuitRefInput!
  ): UpdateCircuitPayload

  """Updates a single `Circuit` using a unique key and a patch."""
  updateCircuitByUrl(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCircuitByUrlInput!
  ): UpdateCircuitPayload

  """
  Updates a single `DriverStanding` using its globally unique id and a patch.
  """
  updateDriverStandingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDriverStandingByNodeIdInput!
  ): UpdateDriverStandingPayload

  """Updates a single `DriverStanding` using a unique key and a patch."""
  updateDriverStanding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDriverStandingInput!
  ): UpdateDriverStandingPayload

  """Updates a single `Driver` using its globally unique id and a patch."""
  updateDriverByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDriverByNodeIdInput!
  ): UpdateDriverPayload

  """Updates a single `Driver` using a unique key and a patch."""
  updateDriver(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDriverInput!
  ): UpdateDriverPayload

  """Updates a single `Driver` using a unique key and a patch."""
  updateDriverByDriverRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDriverByDriverRefInput!
  ): UpdateDriverPayload

  """Updates a single `Driver` using a unique key and a patch."""
  updateDriverByUrl(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDriverByUrlInput!
  ): UpdateDriverPayload

  """Updates a single `LapTime` using its globally unique id and a patch."""
  updateLapTimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLapTimeByNodeIdInput!
  ): UpdateLapTimePayload

  """Updates a single `LapTime` using a unique key and a patch."""
  updateLapTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLapTimeInput!
  ): UpdateLapTimePayload

  """Updates a single `PitStop` using its globally unique id and a patch."""
  updatePitStopByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePitStopByNodeIdInput!
  ): UpdatePitStopPayload

  """Updates a single `PitStop` using a unique key and a patch."""
  updatePitStop(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePitStopInput!
  ): UpdatePitStopPayload

  """
  Updates a single `Qualifying` using its globally unique id and a patch.
  """
  updateQualifyingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateQualifyingByNodeIdInput!
  ): UpdateQualifyingPayload

  """Updates a single `Qualifying` using a unique key and a patch."""
  updateQualifying(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateQualifyingInput!
  ): UpdateQualifyingPayload

  """Updates a single `Race` using its globally unique id and a patch."""
  updateRaceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRaceByNodeIdInput!
  ): UpdateRacePayload

  """Updates a single `Race` using a unique key and a patch."""
  updateRace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRaceInput!
  ): UpdateRacePayload

  """Updates a single `Race` using a unique key and a patch."""
  updateRaceByYearAndRound(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRaceByYearAndRoundInput!
  ): UpdateRacePayload

  """Updates a single `Result` using its globally unique id and a patch."""
  updateResultByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateResultByNodeIdInput!
  ): UpdateResultPayload

  """Updates a single `Result` using a unique key and a patch."""
  updateResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateResultInput!
  ): UpdateResultPayload

  """Updates a single `Season` using its globally unique id and a patch."""
  updateSeasonByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSeasonByNodeIdInput!
  ): UpdateSeasonPayload

  """Updates a single `Season` using a unique key and a patch."""
  updateSeason(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSeasonInput!
  ): UpdateSeasonPayload

  """Updates a single `Season` using a unique key and a patch."""
  updateSeasonByUrl(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSeasonByUrlInput!
  ): UpdateSeasonPayload

  """
  Updates a single `SprintResult` using its globally unique id and a patch.
  """
  updateSprintResultByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSprintResultByNodeIdInput!
  ): UpdateSprintResultPayload

  """Updates a single `SprintResult` using a unique key and a patch."""
  updateSprintResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSprintResultInput!
  ): UpdateSprintResultPayload

  """Updates a single `Status` using its globally unique id and a patch."""
  updateStatusByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStatusByNodeIdInput!
  ): UpdateStatusPayload

  """Updates a single `Status` using a unique key and a patch."""
  updateStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStatusInput!
  ): UpdateStatusPayload

  """Updates a single `TeamColor` using its globally unique id and a patch."""
  updateTeamColorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamColorByNodeIdInput!
  ): UpdateTeamColorPayload

  """Updates a single `TeamColor` using a unique key and a patch."""
  updateTeamColor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamColorInput!
  ): UpdateTeamColorPayload

  """
  Updates a single `TeamHistory` using its globally unique id and a patch.
  """
  updateTeamHistoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamHistoryByNodeIdInput!
  ): UpdateTeamHistoryPayload

  """Updates a single `TeamHistory` using a unique key and a patch."""
  updateTeamHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamHistoryInput!
  ): UpdateTeamHistoryPayload

  """
  Updates a single `TeamResult` using its globally unique id and a patch.
  """
  updateTeamResultByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamResultByNodeIdInput!
  ): UpdateTeamResultPayload

  """Updates a single `TeamResult` using a unique key and a patch."""
  updateTeamResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamResultInput!
  ): UpdateTeamResultPayload

  """
  Updates a single `TeamStanding` using its globally unique id and a patch.
  """
  updateTeamStandingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamStandingByNodeIdInput!
  ): UpdateTeamStandingPayload

  """Updates a single `TeamStanding` using a unique key and a patch."""
  updateTeamStanding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamStandingInput!
  ): UpdateTeamStandingPayload

  """Updates a single `Team` using its globally unique id and a patch."""
  updateTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamByNodeIdInput!
  ): UpdateTeamPayload

  """Updates a single `Team` using a unique key and a patch."""
  updateTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamInput!
  ): UpdateTeamPayload

  """Updates a single `Team` using a unique key and a patch."""
  updateTeamByConstructorRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamByConstructorRefInput!
  ): UpdateTeamPayload

  """Deletes a single `CircuitDescription` using its globally unique id."""
  deleteCircuitDescriptionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCircuitDescriptionByNodeIdInput!
  ): DeleteCircuitDescriptionPayload

  """Deletes a single `CircuitDescription` using a unique key."""
  deleteCircuitDescription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCircuitDescriptionInput!
  ): DeleteCircuitDescriptionPayload

  """Deletes a single `Circuit` using its globally unique id."""
  deleteCircuitByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCircuitByNodeIdInput!
  ): DeleteCircuitPayload

  """Deletes a single `Circuit` using a unique key."""
  deleteCircuit(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCircuitInput!
  ): DeleteCircuitPayload

  """Deletes a single `Circuit` using a unique key."""
  deleteCircuitByCircuitRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCircuitByCircuitRefInput!
  ): DeleteCircuitPayload

  """Deletes a single `Circuit` using a unique key."""
  deleteCircuitByUrl(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCircuitByUrlInput!
  ): DeleteCircuitPayload

  """Deletes a single `DriverStanding` using its globally unique id."""
  deleteDriverStandingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDriverStandingByNodeIdInput!
  ): DeleteDriverStandingPayload

  """Deletes a single `DriverStanding` using a unique key."""
  deleteDriverStanding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDriverStandingInput!
  ): DeleteDriverStandingPayload

  """Deletes a single `Driver` using its globally unique id."""
  deleteDriverByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDriverByNodeIdInput!
  ): DeleteDriverPayload

  """Deletes a single `Driver` using a unique key."""
  deleteDriver(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDriverInput!
  ): DeleteDriverPayload

  """Deletes a single `Driver` using a unique key."""
  deleteDriverByDriverRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDriverByDriverRefInput!
  ): DeleteDriverPayload

  """Deletes a single `Driver` using a unique key."""
  deleteDriverByUrl(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDriverByUrlInput!
  ): DeleteDriverPayload

  """Deletes a single `LapTime` using its globally unique id."""
  deleteLapTimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLapTimeByNodeIdInput!
  ): DeleteLapTimePayload

  """Deletes a single `LapTime` using a unique key."""
  deleteLapTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLapTimeInput!
  ): DeleteLapTimePayload

  """Deletes a single `PitStop` using its globally unique id."""
  deletePitStopByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePitStopByNodeIdInput!
  ): DeletePitStopPayload

  """Deletes a single `PitStop` using a unique key."""
  deletePitStop(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePitStopInput!
  ): DeletePitStopPayload

  """Deletes a single `Qualifying` using its globally unique id."""
  deleteQualifyingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteQualifyingByNodeIdInput!
  ): DeleteQualifyingPayload

  """Deletes a single `Qualifying` using a unique key."""
  deleteQualifying(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteQualifyingInput!
  ): DeleteQualifyingPayload

  """Deletes a single `Race` using its globally unique id."""
  deleteRaceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRaceByNodeIdInput!
  ): DeleteRacePayload

  """Deletes a single `Race` using a unique key."""
  deleteRace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRaceInput!
  ): DeleteRacePayload

  """Deletes a single `Race` using a unique key."""
  deleteRaceByYearAndRound(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRaceByYearAndRoundInput!
  ): DeleteRacePayload

  """Deletes a single `Result` using its globally unique id."""
  deleteResultByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteResultByNodeIdInput!
  ): DeleteResultPayload

  """Deletes a single `Result` using a unique key."""
  deleteResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteResultInput!
  ): DeleteResultPayload

  """Deletes a single `Season` using its globally unique id."""
  deleteSeasonByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSeasonByNodeIdInput!
  ): DeleteSeasonPayload

  """Deletes a single `Season` using a unique key."""
  deleteSeason(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSeasonInput!
  ): DeleteSeasonPayload

  """Deletes a single `Season` using a unique key."""
  deleteSeasonByUrl(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSeasonByUrlInput!
  ): DeleteSeasonPayload

  """Deletes a single `SprintResult` using its globally unique id."""
  deleteSprintResultByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSprintResultByNodeIdInput!
  ): DeleteSprintResultPayload

  """Deletes a single `SprintResult` using a unique key."""
  deleteSprintResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSprintResultInput!
  ): DeleteSprintResultPayload

  """Deletes a single `Status` using its globally unique id."""
  deleteStatusByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStatusByNodeIdInput!
  ): DeleteStatusPayload

  """Deletes a single `Status` using a unique key."""
  deleteStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStatusInput!
  ): DeleteStatusPayload

  """Deletes a single `TeamColor` using its globally unique id."""
  deleteTeamColorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamColorByNodeIdInput!
  ): DeleteTeamColorPayload

  """Deletes a single `TeamColor` using a unique key."""
  deleteTeamColor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamColorInput!
  ): DeleteTeamColorPayload

  """Deletes a single `TeamHistory` using its globally unique id."""
  deleteTeamHistoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamHistoryByNodeIdInput!
  ): DeleteTeamHistoryPayload

  """Deletes a single `TeamHistory` using a unique key."""
  deleteTeamHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamHistoryInput!
  ): DeleteTeamHistoryPayload

  """Deletes a single `TeamResult` using its globally unique id."""
  deleteTeamResultByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamResultByNodeIdInput!
  ): DeleteTeamResultPayload

  """Deletes a single `TeamResult` using a unique key."""
  deleteTeamResult(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamResultInput!
  ): DeleteTeamResultPayload

  """Deletes a single `TeamStanding` using its globally unique id."""
  deleteTeamStandingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamStandingByNodeIdInput!
  ): DeleteTeamStandingPayload

  """Deletes a single `TeamStanding` using a unique key."""
  deleteTeamStanding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamStandingInput!
  ): DeleteTeamStandingPayload

  """Deletes a single `Team` using its globally unique id."""
  deleteTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamByNodeIdInput!
  ): DeleteTeamPayload

  """Deletes a single `Team` using a unique key."""
  deleteTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamInput!
  ): DeleteTeamPayload

  """Deletes a single `Team` using a unique key."""
  deleteTeamByConstructorRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamByConstructorRefInput!
  ): DeleteTeamPayload
}

"""The output of our create `CircuitDescription` mutation."""
type CreateCircuitDescriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CircuitDescription` that was created by this mutation."""
  circuitDescription: CircuitDescription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Circuit` that is related to this `CircuitDescription`."""
  circuit: Circuit

  """An edge for our `CircuitDescription`. May be used by Relay 1."""
  circuitDescriptionEdge(
    """The method to use when ordering `CircuitDescription`."""
    orderBy: [CircuitDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CircuitDescriptionsEdge
}

"""All input for the create `CircuitDescription` mutation."""
input CreateCircuitDescriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CircuitDescription` to be created by this mutation."""
  circuitDescription: CircuitDescriptionInput!
}

"""An input for mutations affecting `CircuitDescription`"""
input CircuitDescriptionInput {
  circuitId: Int!
  description: String
}

"""The output of our create `Circuit` mutation."""
type CreateCircuitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Circuit` that was created by this mutation."""
  circuit: Circuit

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Circuit`. May be used by Relay 1."""
  circuitEdge(
    """The method to use when ordering `Circuit`."""
    orderBy: [CircuitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CircuitsEdge
}

"""All input for the create `Circuit` mutation."""
input CreateCircuitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Circuit` to be created by this mutation."""
  circuit: CircuitInput!
}

"""An input for mutations affecting `Circuit`"""
input CircuitInput {
  circuitId: Int!
  circuitRef: String
  name: String
  location: String
  country: String
  lat: Float
  lng: Float
  alt: Int
  url: String
}

"""The output of our create `DriverStanding` mutation."""
type CreateDriverStandingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DriverStanding` that was created by this mutation."""
  driverStanding: DriverStanding

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `DriverStanding`."""
  race: Race

  """Reads a single `Driver` that is related to this `DriverStanding`."""
  driver: Driver

  """An edge for our `DriverStanding`. May be used by Relay 1."""
  driverStandingEdge(
    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DriverStandingsEdge
}

"""All input for the create `DriverStanding` mutation."""
input CreateDriverStandingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `DriverStanding` to be created by this mutation."""
  driverStanding: DriverStandingInput!
}

"""An input for mutations affecting `DriverStanding`"""
input DriverStandingInput {
  driverStandingsId: Int!
  raceId: Int
  driverId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int
}

"""The output of our create `Driver` mutation."""
type CreateDriverPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Driver` that was created by this mutation."""
  driver: Driver

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Driver`. May be used by Relay 1."""
  driverEdge(
    """The method to use when ordering `Driver`."""
    orderBy: [DriversOrderBy!] = [PRIMARY_KEY_ASC]
  ): DriversEdge
}

"""All input for the create `Driver` mutation."""
input CreateDriverInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Driver` to be created by this mutation."""
  driver: DriverInput!
}

"""An input for mutations affecting `Driver`"""
input DriverInput {
  driverId: Int!
  driverRef: String!
  number: Int
  code: String
  forename: String
  surname: String
  dob: Date
  nationality: String
  url: String
}

"""The output of our create `LapTime` mutation."""
type CreateLapTimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LapTime` that was created by this mutation."""
  lapTime: LapTime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `LapTime`."""
  race: Race

  """Reads a single `Driver` that is related to this `LapTime`."""
  driver: Driver

  """An edge for our `LapTime`. May be used by Relay 1."""
  lapTimeEdge(
    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LapTimesEdge
}

"""All input for the create `LapTime` mutation."""
input CreateLapTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LapTime` to be created by this mutation."""
  lapTime: LapTimeInput!
}

"""An input for mutations affecting `LapTime`"""
input LapTimeInput {
  raceId: Int!
  driverId: Int!
  lap: Int!
  position: Int
  time: String
  milliseconds: Int
}

"""The output of our create `PitStop` mutation."""
type CreatePitStopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PitStop` that was created by this mutation."""
  pitStop: PitStop

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `PitStop`."""
  race: Race

  """Reads a single `Driver` that is related to this `PitStop`."""
  driver: Driver

  """An edge for our `PitStop`. May be used by Relay 1."""
  pitStopEdge(
    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PitStopsEdge
}

"""All input for the create `PitStop` mutation."""
input CreatePitStopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PitStop` to be created by this mutation."""
  pitStop: PitStopInput!
}

"""An input for mutations affecting `PitStop`"""
input PitStopInput {
  raceId: Int!
  driverId: Int!
  stop: Int!
  lap: Int
  time: String
  duration: String
  milliseconds: Int
}

"""The output of our create `Qualifying` mutation."""
type CreateQualifyingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Qualifying` that was created by this mutation."""
  qualifying: Qualifying

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `Qualifying`."""
  race: Race

  """Reads a single `Driver` that is related to this `Qualifying`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Qualifying`."""
  team: Team

  """An edge for our `Qualifying`. May be used by Relay 1."""
  qualifyingEdge(
    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): QualifyingsEdge
}

"""All input for the create `Qualifying` mutation."""
input CreateQualifyingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Qualifying` to be created by this mutation."""
  qualifying: QualifyingInput!
}

"""An input for mutations affecting `Qualifying`"""
input QualifyingInput {
  qualifyId: Int!
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  position: Int
  q1: String
  q2: String
  q3: String
}

"""The output of our create `Race` mutation."""
type CreateRacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Race` that was created by this mutation."""
  race: Race

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Season` that is related to this `Race`."""
  seasonByYear: Season

  """Reads a single `Circuit` that is related to this `Race`."""
  circuit: Circuit

  """An edge for our `Race`. May be used by Relay 1."""
  raceEdge(
    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RacesEdge
}

"""All input for the create `Race` mutation."""
input CreateRaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Race` to be created by this mutation."""
  race: RaceInput!
}

"""An input for mutations affecting `Race`"""
input RaceInput {
  raceId: Int!
  year: Int
  round: Int
  circuitId: Int
  name: String
  date: Date
  time: String
  url: String
  fp1Date: Date
  fp1Time: String
  fp2Date: Date
  fp2Time: String
  fp3Date: Date
  fp3Time: String
  qualiDate: Date
  qualiTime: String
  sprintDate: Date
  sprintTime: String
}

"""The output of our create `Result` mutation."""
type CreateResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Result` that was created by this mutation."""
  result: Result

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `Result`."""
  race: Race

  """Reads a single `Driver` that is related to this `Result`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Result`."""
  team: Team

  """Reads a single `Status` that is related to this `Result`."""
  status: Status

  """An edge for our `Result`. May be used by Relay 1."""
  resultEdge(
    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ResultsEdge
}

"""All input for the create `Result` mutation."""
input CreateResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Result` to be created by this mutation."""
  result: ResultInput!
}

"""An input for mutations affecting `Result`"""
input ResultInput {
  resultId: Int!
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  grid: Int
  position: Int
  positionText: String
  positionOrder: Int
  points: Float
  laps: Int
  time: String
  milliseconds: Int
  fastestLap: Int
  rank: Int
  fastestLapTime: String
  fastestLapSpeed: String
  statusId: Int
}

"""The output of our create `Season` mutation."""
type CreateSeasonPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Season` that was created by this mutation."""
  season: Season

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Season`. May be used by Relay 1."""
  seasonEdge(
    """The method to use when ordering `Season`."""
    orderBy: [SeasonsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SeasonsEdge
}

"""All input for the create `Season` mutation."""
input CreateSeasonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Season` to be created by this mutation."""
  season: SeasonInput!
}

"""An input for mutations affecting `Season`"""
input SeasonInput {
  year: Int!
  url: String
}

"""The output of our create `SprintResult` mutation."""
type CreateSprintResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SprintResult` that was created by this mutation."""
  sprintResult: SprintResult

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `SprintResult`."""
  race: Race

  """Reads a single `Driver` that is related to this `SprintResult`."""
  driver: Driver

  """Reads a single `Team` that is related to this `SprintResult`."""
  team: Team

  """Reads a single `Status` that is related to this `SprintResult`."""
  status: Status

  """An edge for our `SprintResult`. May be used by Relay 1."""
  sprintResultEdge(
    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SprintResultsEdge
}

"""All input for the create `SprintResult` mutation."""
input CreateSprintResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `SprintResult` to be created by this mutation."""
  sprintResult: SprintResultInput!
}

"""An input for mutations affecting `SprintResult`"""
input SprintResultInput {
  sprintResultId: Int!
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  grid: Int
  position: Int
  positionText: String
  positionOrder: Int
  points: Float
  laps: Int
  time: String
  milliseconds: Int
  fastestLap: Int
  fastestLapTime: String
  statusId: Int
}

"""The output of our create `Status` mutation."""
type CreateStatusPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Status` that was created by this mutation."""
  status: Status

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Status`. May be used by Relay 1."""
  statusEdge(
    """The method to use when ordering `Status`."""
    orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatusesEdge
}

"""All input for the create `Status` mutation."""
input CreateStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Status` to be created by this mutation."""
  status: StatusInput!
}

"""An input for mutations affecting `Status`"""
input StatusInput {
  statusId: Int!
  status: String
}

"""The output of our create `TeamColor` mutation."""
type CreateTeamColorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamColor` that was created by this mutation."""
  teamColor: TeamColor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `TeamColor`."""
  team: Team

  """An edge for our `TeamColor`. May be used by Relay 1."""
  teamColorEdge(
    """The method to use when ordering `TeamColor`."""
    orderBy: [TeamColorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamColorsEdge
}

"""All input for the create `TeamColor` mutation."""
input CreateTeamColorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TeamColor` to be created by this mutation."""
  teamColor: TeamColorInput!
}

"""An input for mutations affecting `TeamColor`"""
input TeamColorInput {
  teamId: Int!
  primary: String
  secondary: String
  logo: String
}

"""The output of our create `TeamHistory` mutation."""
type CreateTeamHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamHistory` that was created by this mutation."""
  teamHistory: TeamHistory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `TeamHistory`."""
  team: Team

  """Reads a single `Team` that is related to this `TeamHistory`."""
  antecedentTeam: Team

  """An edge for our `TeamHistory`. May be used by Relay 1."""
  teamHistoryEdge(
    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamHistoriesEdge
}

"""All input for the create `TeamHistory` mutation."""
input CreateTeamHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TeamHistory` to be created by this mutation."""
  teamHistory: TeamHistoryInput!
}

"""An input for mutations affecting `TeamHistory`"""
input TeamHistoryInput {
  teamId: Int!
  antecedentTeamId: Int!
  startYear: Int!
  endYear: Int
}

"""The output of our create `TeamResult` mutation."""
type CreateTeamResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamResult` that was created by this mutation."""
  teamResult: TeamResult

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `TeamResult`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamResult`."""
  team: Team

  """An edge for our `TeamResult`. May be used by Relay 1."""
  teamResultEdge(
    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamResultsEdge
}

"""All input for the create `TeamResult` mutation."""
input CreateTeamResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TeamResult` to be created by this mutation."""
  teamResult: TeamResultInput!
}

"""An input for mutations affecting `TeamResult`"""
input TeamResultInput {
  constructorResultsId: Int!
  raceId: Int
  teamId: Int
  points: Float
  status: String
}

"""The output of our create `TeamStanding` mutation."""
type CreateTeamStandingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamStanding` that was created by this mutation."""
  teamStanding: TeamStanding

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `TeamStanding`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamStanding`."""
  team: Team

  """An edge for our `TeamStanding`. May be used by Relay 1."""
  teamStandingEdge(
    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamStandingsEdge
}

"""All input for the create `TeamStanding` mutation."""
input CreateTeamStandingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TeamStanding` to be created by this mutation."""
  teamStanding: TeamStandingInput!
}

"""An input for mutations affecting `TeamStanding`"""
input TeamStandingInput {
  constructorStandingsId: Int!
  raceId: Int
  teamId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int
}

"""The output of our create `Team` mutation."""
type CreateTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was created by this mutation."""
  team: Team

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Team`. May be used by Relay 1."""
  teamEdge(
    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamsEdge
}

"""All input for the create `Team` mutation."""
input CreateTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Team` to be created by this mutation."""
  team: TeamInput!
}

"""An input for mutations affecting `Team`"""
input TeamInput {
  teamId: Int!
  constructorRef: String
  name: String
  nationality: String
  url: String
}

"""The output of our update `CircuitDescription` mutation."""
type UpdateCircuitDescriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CircuitDescription` that was updated by this mutation."""
  circuitDescription: CircuitDescription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Circuit` that is related to this `CircuitDescription`."""
  circuit: Circuit

  """An edge for our `CircuitDescription`. May be used by Relay 1."""
  circuitDescriptionEdge(
    """The method to use when ordering `CircuitDescription`."""
    orderBy: [CircuitDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CircuitDescriptionsEdge
}

"""All input for the `updateCircuitDescriptionByNodeId` mutation."""
input UpdateCircuitDescriptionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CircuitDescription` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CircuitDescription` being updated.
  """
  patch: CircuitDescriptionPatch!
}

"""
Represents an update to a `CircuitDescription`. Fields that are set will be updated.
"""
input CircuitDescriptionPatch {
  circuitId: Int
  description: String
}

"""All input for the `updateCircuitDescription` mutation."""
input UpdateCircuitDescriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CircuitDescription` being updated.
  """
  patch: CircuitDescriptionPatch!
  circuitId: Int!
}

"""The output of our update `Circuit` mutation."""
type UpdateCircuitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Circuit` that was updated by this mutation."""
  circuit: Circuit

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Circuit`. May be used by Relay 1."""
  circuitEdge(
    """The method to use when ordering `Circuit`."""
    orderBy: [CircuitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CircuitsEdge
}

"""All input for the `updateCircuitByNodeId` mutation."""
input UpdateCircuitByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Circuit` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Circuit` being updated.
  """
  patch: CircuitPatch!
}

"""
Represents an update to a `Circuit`. Fields that are set will be updated.
"""
input CircuitPatch {
  circuitId: Int
  circuitRef: String
  name: String
  location: String
  country: String
  lat: Float
  lng: Float
  alt: Int
  url: String
}

"""All input for the `updateCircuit` mutation."""
input UpdateCircuitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Circuit` being updated.
  """
  patch: CircuitPatch!
  circuitId: Int!
}

"""All input for the `updateCircuitByCircuitRef` mutation."""
input UpdateCircuitByCircuitRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Circuit` being updated.
  """
  patch: CircuitPatch!
  circuitRef: String!
}

"""All input for the `updateCircuitByUrl` mutation."""
input UpdateCircuitByUrlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Circuit` being updated.
  """
  patch: CircuitPatch!
  url: String!
}

"""The output of our update `DriverStanding` mutation."""
type UpdateDriverStandingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DriverStanding` that was updated by this mutation."""
  driverStanding: DriverStanding

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `DriverStanding`."""
  race: Race

  """Reads a single `Driver` that is related to this `DriverStanding`."""
  driver: Driver

  """An edge for our `DriverStanding`. May be used by Relay 1."""
  driverStandingEdge(
    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DriverStandingsEdge
}

"""All input for the `updateDriverStandingByNodeId` mutation."""
input UpdateDriverStandingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DriverStanding` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `DriverStanding` being updated.
  """
  patch: DriverStandingPatch!
}

"""
Represents an update to a `DriverStanding`. Fields that are set will be updated.
"""
input DriverStandingPatch {
  driverStandingsId: Int
  raceId: Int
  driverId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int
}

"""All input for the `updateDriverStanding` mutation."""
input UpdateDriverStandingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `DriverStanding` being updated.
  """
  patch: DriverStandingPatch!
  driverStandingsId: Int!
}

"""The output of our update `Driver` mutation."""
type UpdateDriverPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Driver` that was updated by this mutation."""
  driver: Driver

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Driver`. May be used by Relay 1."""
  driverEdge(
    """The method to use when ordering `Driver`."""
    orderBy: [DriversOrderBy!] = [PRIMARY_KEY_ASC]
  ): DriversEdge
}

"""All input for the `updateDriverByNodeId` mutation."""
input UpdateDriverByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Driver` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Driver` being updated.
  """
  patch: DriverPatch!
}

"""
Represents an update to a `Driver`. Fields that are set will be updated.
"""
input DriverPatch {
  driverId: Int
  driverRef: String
  number: Int
  code: String
  forename: String
  surname: String
  dob: Date
  nationality: String
  url: String
}

"""All input for the `updateDriver` mutation."""
input UpdateDriverInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Driver` being updated.
  """
  patch: DriverPatch!
  driverId: Int!
}

"""All input for the `updateDriverByDriverRef` mutation."""
input UpdateDriverByDriverRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Driver` being updated.
  """
  patch: DriverPatch!
  driverRef: String!
}

"""All input for the `updateDriverByUrl` mutation."""
input UpdateDriverByUrlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Driver` being updated.
  """
  patch: DriverPatch!
  url: String!
}

"""The output of our update `LapTime` mutation."""
type UpdateLapTimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LapTime` that was updated by this mutation."""
  lapTime: LapTime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `LapTime`."""
  race: Race

  """Reads a single `Driver` that is related to this `LapTime`."""
  driver: Driver

  """An edge for our `LapTime`. May be used by Relay 1."""
  lapTimeEdge(
    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LapTimesEdge
}

"""All input for the `updateLapTimeByNodeId` mutation."""
input UpdateLapTimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LapTime` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LapTime` being updated.
  """
  patch: LapTimePatch!
}

"""
Represents an update to a `LapTime`. Fields that are set will be updated.
"""
input LapTimePatch {
  raceId: Int
  driverId: Int
  lap: Int
  position: Int
  time: String
  milliseconds: Int
}

"""All input for the `updateLapTime` mutation."""
input UpdateLapTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LapTime` being updated.
  """
  patch: LapTimePatch!
  raceId: Int!
  driverId: Int!
  lap: Int!
}

"""The output of our update `PitStop` mutation."""
type UpdatePitStopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PitStop` that was updated by this mutation."""
  pitStop: PitStop

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `PitStop`."""
  race: Race

  """Reads a single `Driver` that is related to this `PitStop`."""
  driver: Driver

  """An edge for our `PitStop`. May be used by Relay 1."""
  pitStopEdge(
    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PitStopsEdge
}

"""All input for the `updatePitStopByNodeId` mutation."""
input UpdatePitStopByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PitStop` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PitStop` being updated.
  """
  patch: PitStopPatch!
}

"""
Represents an update to a `PitStop`. Fields that are set will be updated.
"""
input PitStopPatch {
  raceId: Int
  driverId: Int
  stop: Int
  lap: Int
  time: String
  duration: String
  milliseconds: Int
}

"""All input for the `updatePitStop` mutation."""
input UpdatePitStopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PitStop` being updated.
  """
  patch: PitStopPatch!
  raceId: Int!
  driverId: Int!
  stop: Int!
}

"""The output of our update `Qualifying` mutation."""
type UpdateQualifyingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Qualifying` that was updated by this mutation."""
  qualifying: Qualifying

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `Qualifying`."""
  race: Race

  """Reads a single `Driver` that is related to this `Qualifying`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Qualifying`."""
  team: Team

  """An edge for our `Qualifying`. May be used by Relay 1."""
  qualifyingEdge(
    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): QualifyingsEdge
}

"""All input for the `updateQualifyingByNodeId` mutation."""
input UpdateQualifyingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Qualifying` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Qualifying` being updated.
  """
  patch: QualifyingPatch!
}

"""
Represents an update to a `Qualifying`. Fields that are set will be updated.
"""
input QualifyingPatch {
  qualifyId: Int
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  position: Int
  q1: String
  q2: String
  q3: String
}

"""All input for the `updateQualifying` mutation."""
input UpdateQualifyingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Qualifying` being updated.
  """
  patch: QualifyingPatch!
  qualifyId: Int!
}

"""The output of our update `Race` mutation."""
type UpdateRacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Race` that was updated by this mutation."""
  race: Race

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Season` that is related to this `Race`."""
  seasonByYear: Season

  """Reads a single `Circuit` that is related to this `Race`."""
  circuit: Circuit

  """An edge for our `Race`. May be used by Relay 1."""
  raceEdge(
    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RacesEdge
}

"""All input for the `updateRaceByNodeId` mutation."""
input UpdateRaceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Race` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Race` being updated.
  """
  patch: RacePatch!
}

"""Represents an update to a `Race`. Fields that are set will be updated."""
input RacePatch {
  raceId: Int
  year: Int
  round: Int
  circuitId: Int
  name: String
  date: Date
  time: String
  url: String
  fp1Date: Date
  fp1Time: String
  fp2Date: Date
  fp2Time: String
  fp3Date: Date
  fp3Time: String
  qualiDate: Date
  qualiTime: String
  sprintDate: Date
  sprintTime: String
}

"""All input for the `updateRace` mutation."""
input UpdateRaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Race` being updated.
  """
  patch: RacePatch!
  raceId: Int!
}

"""All input for the `updateRaceByYearAndRound` mutation."""
input UpdateRaceByYearAndRoundInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Race` being updated.
  """
  patch: RacePatch!
  year: Int!
  round: Int!
}

"""The output of our update `Result` mutation."""
type UpdateResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Result` that was updated by this mutation."""
  result: Result

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `Result`."""
  race: Race

  """Reads a single `Driver` that is related to this `Result`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Result`."""
  team: Team

  """Reads a single `Status` that is related to this `Result`."""
  status: Status

  """An edge for our `Result`. May be used by Relay 1."""
  resultEdge(
    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ResultsEdge
}

"""All input for the `updateResultByNodeId` mutation."""
input UpdateResultByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Result` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Result` being updated.
  """
  patch: ResultPatch!
}

"""
Represents an update to a `Result`. Fields that are set will be updated.
"""
input ResultPatch {
  resultId: Int
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  grid: Int
  position: Int
  positionText: String
  positionOrder: Int
  points: Float
  laps: Int
  time: String
  milliseconds: Int
  fastestLap: Int
  rank: Int
  fastestLapTime: String
  fastestLapSpeed: String
  statusId: Int
}

"""All input for the `updateResult` mutation."""
input UpdateResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Result` being updated.
  """
  patch: ResultPatch!
  resultId: Int!
}

"""The output of our update `Season` mutation."""
type UpdateSeasonPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Season` that was updated by this mutation."""
  season: Season

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Season`. May be used by Relay 1."""
  seasonEdge(
    """The method to use when ordering `Season`."""
    orderBy: [SeasonsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SeasonsEdge
}

"""All input for the `updateSeasonByNodeId` mutation."""
input UpdateSeasonByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Season` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Season` being updated.
  """
  patch: SeasonPatch!
}

"""
Represents an update to a `Season`. Fields that are set will be updated.
"""
input SeasonPatch {
  year: Int
  url: String
}

"""All input for the `updateSeason` mutation."""
input UpdateSeasonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Season` being updated.
  """
  patch: SeasonPatch!
  year: Int!
}

"""All input for the `updateSeasonByUrl` mutation."""
input UpdateSeasonByUrlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Season` being updated.
  """
  patch: SeasonPatch!
  url: String!
}

"""The output of our update `SprintResult` mutation."""
type UpdateSprintResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SprintResult` that was updated by this mutation."""
  sprintResult: SprintResult

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `SprintResult`."""
  race: Race

  """Reads a single `Driver` that is related to this `SprintResult`."""
  driver: Driver

  """Reads a single `Team` that is related to this `SprintResult`."""
  team: Team

  """Reads a single `Status` that is related to this `SprintResult`."""
  status: Status

  """An edge for our `SprintResult`. May be used by Relay 1."""
  sprintResultEdge(
    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SprintResultsEdge
}

"""All input for the `updateSprintResultByNodeId` mutation."""
input UpdateSprintResultByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SprintResult` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `SprintResult` being updated.
  """
  patch: SprintResultPatch!
}

"""
Represents an update to a `SprintResult`. Fields that are set will be updated.
"""
input SprintResultPatch {
  sprintResultId: Int
  raceId: Int
  driverId: Int
  teamId: Int
  number: Int
  grid: Int
  position: Int
  positionText: String
  positionOrder: Int
  points: Float
  laps: Int
  time: String
  milliseconds: Int
  fastestLap: Int
  fastestLapTime: String
  statusId: Int
}

"""All input for the `updateSprintResult` mutation."""
input UpdateSprintResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `SprintResult` being updated.
  """
  patch: SprintResultPatch!
  sprintResultId: Int!
}

"""The output of our update `Status` mutation."""
type UpdateStatusPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Status` that was updated by this mutation."""
  status: Status

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Status`. May be used by Relay 1."""
  statusEdge(
    """The method to use when ordering `Status`."""
    orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatusesEdge
}

"""All input for the `updateStatusByNodeId` mutation."""
input UpdateStatusByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Status` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Status` being updated.
  """
  patch: StatusPatch!
}

"""
Represents an update to a `Status`. Fields that are set will be updated.
"""
input StatusPatch {
  statusId: Int
  status: String
}

"""All input for the `updateStatus` mutation."""
input UpdateStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Status` being updated.
  """
  patch: StatusPatch!
  statusId: Int!
}

"""The output of our update `TeamColor` mutation."""
type UpdateTeamColorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamColor` that was updated by this mutation."""
  teamColor: TeamColor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `TeamColor`."""
  team: Team

  """An edge for our `TeamColor`. May be used by Relay 1."""
  teamColorEdge(
    """The method to use when ordering `TeamColor`."""
    orderBy: [TeamColorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamColorsEdge
}

"""All input for the `updateTeamColorByNodeId` mutation."""
input UpdateTeamColorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamColor` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TeamColor` being updated.
  """
  patch: TeamColorPatch!
}

"""
Represents an update to a `TeamColor`. Fields that are set will be updated.
"""
input TeamColorPatch {
  teamId: Int
  primary: String
  secondary: String
  logo: String
}

"""All input for the `updateTeamColor` mutation."""
input UpdateTeamColorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TeamColor` being updated.
  """
  patch: TeamColorPatch!
  teamId: Int!
}

"""The output of our update `TeamHistory` mutation."""
type UpdateTeamHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamHistory` that was updated by this mutation."""
  teamHistory: TeamHistory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `TeamHistory`."""
  team: Team

  """Reads a single `Team` that is related to this `TeamHistory`."""
  antecedentTeam: Team

  """An edge for our `TeamHistory`. May be used by Relay 1."""
  teamHistoryEdge(
    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamHistoriesEdge
}

"""All input for the `updateTeamHistoryByNodeId` mutation."""
input UpdateTeamHistoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamHistory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TeamHistory` being updated.
  """
  patch: TeamHistoryPatch!
}

"""
Represents an update to a `TeamHistory`. Fields that are set will be updated.
"""
input TeamHistoryPatch {
  teamId: Int
  antecedentTeamId: Int
  startYear: Int
  endYear: Int
}

"""All input for the `updateTeamHistory` mutation."""
input UpdateTeamHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TeamHistory` being updated.
  """
  patch: TeamHistoryPatch!
  teamId: Int!
  antecedentTeamId: Int!
  startYear: Int!
}

"""The output of our update `TeamResult` mutation."""
type UpdateTeamResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamResult` that was updated by this mutation."""
  teamResult: TeamResult

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `TeamResult`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamResult`."""
  team: Team

  """An edge for our `TeamResult`. May be used by Relay 1."""
  teamResultEdge(
    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamResultsEdge
}

"""All input for the `updateTeamResultByNodeId` mutation."""
input UpdateTeamResultByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamResult` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TeamResult` being updated.
  """
  patch: TeamResultPatch!
}

"""
Represents an update to a `TeamResult`. Fields that are set will be updated.
"""
input TeamResultPatch {
  constructorResultsId: Int
  raceId: Int
  teamId: Int
  points: Float
  status: String
}

"""All input for the `updateTeamResult` mutation."""
input UpdateTeamResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TeamResult` being updated.
  """
  patch: TeamResultPatch!
  constructorResultsId: Int!
}

"""The output of our update `TeamStanding` mutation."""
type UpdateTeamStandingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamStanding` that was updated by this mutation."""
  teamStanding: TeamStanding

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `TeamStanding`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamStanding`."""
  team: Team

  """An edge for our `TeamStanding`. May be used by Relay 1."""
  teamStandingEdge(
    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamStandingsEdge
}

"""All input for the `updateTeamStandingByNodeId` mutation."""
input UpdateTeamStandingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamStanding` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TeamStanding` being updated.
  """
  patch: TeamStandingPatch!
}

"""
Represents an update to a `TeamStanding`. Fields that are set will be updated.
"""
input TeamStandingPatch {
  constructorStandingsId: Int
  raceId: Int
  teamId: Int
  points: Float
  position: Int
  positionText: String
  wins: Int
}

"""All input for the `updateTeamStanding` mutation."""
input UpdateTeamStandingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TeamStanding` being updated.
  """
  patch: TeamStandingPatch!
  constructorStandingsId: Int!
}

"""The output of our update `Team` mutation."""
type UpdateTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was updated by this mutation."""
  team: Team

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Team`. May be used by Relay 1."""
  teamEdge(
    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamsEdge
}

"""All input for the `updateTeamByNodeId` mutation."""
input UpdateTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Team` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
}

"""Represents an update to a `Team`. Fields that are set will be updated."""
input TeamPatch {
  teamId: Int
  constructorRef: String
  name: String
  nationality: String
  url: String
}

"""All input for the `updateTeam` mutation."""
input UpdateTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
  teamId: Int!
}

"""All input for the `updateTeamByConstructorRef` mutation."""
input UpdateTeamByConstructorRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
  constructorRef: String!
}

"""The output of our delete `CircuitDescription` mutation."""
type DeleteCircuitDescriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CircuitDescription` that was deleted by this mutation."""
  circuitDescription: CircuitDescription
  deletedCircuitDescriptionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Circuit` that is related to this `CircuitDescription`."""
  circuit: Circuit

  """An edge for our `CircuitDescription`. May be used by Relay 1."""
  circuitDescriptionEdge(
    """The method to use when ordering `CircuitDescription`."""
    orderBy: [CircuitDescriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CircuitDescriptionsEdge
}

"""All input for the `deleteCircuitDescriptionByNodeId` mutation."""
input DeleteCircuitDescriptionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CircuitDescription` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCircuitDescription` mutation."""
input DeleteCircuitDescriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  circuitId: Int!
}

"""The output of our delete `Circuit` mutation."""
type DeleteCircuitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Circuit` that was deleted by this mutation."""
  circuit: Circuit
  deletedCircuitNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Circuit`. May be used by Relay 1."""
  circuitEdge(
    """The method to use when ordering `Circuit`."""
    orderBy: [CircuitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CircuitsEdge
}

"""All input for the `deleteCircuitByNodeId` mutation."""
input DeleteCircuitByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Circuit` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCircuit` mutation."""
input DeleteCircuitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  circuitId: Int!
}

"""All input for the `deleteCircuitByCircuitRef` mutation."""
input DeleteCircuitByCircuitRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  circuitRef: String!
}

"""All input for the `deleteCircuitByUrl` mutation."""
input DeleteCircuitByUrlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  url: String!
}

"""The output of our delete `DriverStanding` mutation."""
type DeleteDriverStandingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DriverStanding` that was deleted by this mutation."""
  driverStanding: DriverStanding
  deletedDriverStandingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `DriverStanding`."""
  race: Race

  """Reads a single `Driver` that is related to this `DriverStanding`."""
  driver: Driver

  """An edge for our `DriverStanding`. May be used by Relay 1."""
  driverStandingEdge(
    """The method to use when ordering `DriverStanding`."""
    orderBy: [DriverStandingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DriverStandingsEdge
}

"""All input for the `deleteDriverStandingByNodeId` mutation."""
input DeleteDriverStandingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DriverStanding` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDriverStanding` mutation."""
input DeleteDriverStandingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  driverStandingsId: Int!
}

"""The output of our delete `Driver` mutation."""
type DeleteDriverPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Driver` that was deleted by this mutation."""
  driver: Driver
  deletedDriverNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Driver`. May be used by Relay 1."""
  driverEdge(
    """The method to use when ordering `Driver`."""
    orderBy: [DriversOrderBy!] = [PRIMARY_KEY_ASC]
  ): DriversEdge
}

"""All input for the `deleteDriverByNodeId` mutation."""
input DeleteDriverByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Driver` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDriver` mutation."""
input DeleteDriverInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  driverId: Int!
}

"""All input for the `deleteDriverByDriverRef` mutation."""
input DeleteDriverByDriverRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  driverRef: String!
}

"""All input for the `deleteDriverByUrl` mutation."""
input DeleteDriverByUrlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  url: String!
}

"""The output of our delete `LapTime` mutation."""
type DeleteLapTimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LapTime` that was deleted by this mutation."""
  lapTime: LapTime
  deletedLapTimeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `LapTime`."""
  race: Race

  """Reads a single `Driver` that is related to this `LapTime`."""
  driver: Driver

  """An edge for our `LapTime`. May be used by Relay 1."""
  lapTimeEdge(
    """The method to use when ordering `LapTime`."""
    orderBy: [LapTimesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LapTimesEdge
}

"""All input for the `deleteLapTimeByNodeId` mutation."""
input DeleteLapTimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LapTime` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLapTime` mutation."""
input DeleteLapTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  raceId: Int!
  driverId: Int!
  lap: Int!
}

"""The output of our delete `PitStop` mutation."""
type DeletePitStopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PitStop` that was deleted by this mutation."""
  pitStop: PitStop
  deletedPitStopNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `PitStop`."""
  race: Race

  """Reads a single `Driver` that is related to this `PitStop`."""
  driver: Driver

  """An edge for our `PitStop`. May be used by Relay 1."""
  pitStopEdge(
    """The method to use when ordering `PitStop`."""
    orderBy: [PitStopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PitStopsEdge
}

"""All input for the `deletePitStopByNodeId` mutation."""
input DeletePitStopByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PitStop` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePitStop` mutation."""
input DeletePitStopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  raceId: Int!
  driverId: Int!
  stop: Int!
}

"""The output of our delete `Qualifying` mutation."""
type DeleteQualifyingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Qualifying` that was deleted by this mutation."""
  qualifying: Qualifying
  deletedQualifyingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `Qualifying`."""
  race: Race

  """Reads a single `Driver` that is related to this `Qualifying`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Qualifying`."""
  team: Team

  """An edge for our `Qualifying`. May be used by Relay 1."""
  qualifyingEdge(
    """The method to use when ordering `Qualifying`."""
    orderBy: [QualifyingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): QualifyingsEdge
}

"""All input for the `deleteQualifyingByNodeId` mutation."""
input DeleteQualifyingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Qualifying` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteQualifying` mutation."""
input DeleteQualifyingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  qualifyId: Int!
}

"""The output of our delete `Race` mutation."""
type DeleteRacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Race` that was deleted by this mutation."""
  race: Race
  deletedRaceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Season` that is related to this `Race`."""
  seasonByYear: Season

  """Reads a single `Circuit` that is related to this `Race`."""
  circuit: Circuit

  """An edge for our `Race`. May be used by Relay 1."""
  raceEdge(
    """The method to use when ordering `Race`."""
    orderBy: [RacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RacesEdge
}

"""All input for the `deleteRaceByNodeId` mutation."""
input DeleteRaceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Race` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRace` mutation."""
input DeleteRaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  raceId: Int!
}

"""All input for the `deleteRaceByYearAndRound` mutation."""
input DeleteRaceByYearAndRoundInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  year: Int!
  round: Int!
}

"""The output of our delete `Result` mutation."""
type DeleteResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Result` that was deleted by this mutation."""
  result: Result
  deletedResultNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `Result`."""
  race: Race

  """Reads a single `Driver` that is related to this `Result`."""
  driver: Driver

  """Reads a single `Team` that is related to this `Result`."""
  team: Team

  """Reads a single `Status` that is related to this `Result`."""
  status: Status

  """An edge for our `Result`. May be used by Relay 1."""
  resultEdge(
    """The method to use when ordering `Result`."""
    orderBy: [ResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ResultsEdge
}

"""All input for the `deleteResultByNodeId` mutation."""
input DeleteResultByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Result` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteResult` mutation."""
input DeleteResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  resultId: Int!
}

"""The output of our delete `Season` mutation."""
type DeleteSeasonPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Season` that was deleted by this mutation."""
  season: Season
  deletedSeasonNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Season`. May be used by Relay 1."""
  seasonEdge(
    """The method to use when ordering `Season`."""
    orderBy: [SeasonsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SeasonsEdge
}

"""All input for the `deleteSeasonByNodeId` mutation."""
input DeleteSeasonByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Season` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSeason` mutation."""
input DeleteSeasonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  year: Int!
}

"""All input for the `deleteSeasonByUrl` mutation."""
input DeleteSeasonByUrlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  url: String!
}

"""The output of our delete `SprintResult` mutation."""
type DeleteSprintResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SprintResult` that was deleted by this mutation."""
  sprintResult: SprintResult
  deletedSprintResultNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `SprintResult`."""
  race: Race

  """Reads a single `Driver` that is related to this `SprintResult`."""
  driver: Driver

  """Reads a single `Team` that is related to this `SprintResult`."""
  team: Team

  """Reads a single `Status` that is related to this `SprintResult`."""
  status: Status

  """An edge for our `SprintResult`. May be used by Relay 1."""
  sprintResultEdge(
    """The method to use when ordering `SprintResult`."""
    orderBy: [SprintResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SprintResultsEdge
}

"""All input for the `deleteSprintResultByNodeId` mutation."""
input DeleteSprintResultByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SprintResult` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSprintResult` mutation."""
input DeleteSprintResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  sprintResultId: Int!
}

"""The output of our delete `Status` mutation."""
type DeleteStatusPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Status` that was deleted by this mutation."""
  status: Status
  deletedStatusNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Status`. May be used by Relay 1."""
  statusEdge(
    """The method to use when ordering `Status`."""
    orderBy: [StatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatusesEdge
}

"""All input for the `deleteStatusByNodeId` mutation."""
input DeleteStatusByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Status` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStatus` mutation."""
input DeleteStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  statusId: Int!
}

"""The output of our delete `TeamColor` mutation."""
type DeleteTeamColorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamColor` that was deleted by this mutation."""
  teamColor: TeamColor
  deletedTeamColorNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `TeamColor`."""
  team: Team

  """An edge for our `TeamColor`. May be used by Relay 1."""
  teamColorEdge(
    """The method to use when ordering `TeamColor`."""
    orderBy: [TeamColorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamColorsEdge
}

"""All input for the `deleteTeamColorByNodeId` mutation."""
input DeleteTeamColorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamColor` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeamColor` mutation."""
input DeleteTeamColorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  teamId: Int!
}

"""The output of our delete `TeamHistory` mutation."""
type DeleteTeamHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamHistory` that was deleted by this mutation."""
  teamHistory: TeamHistory
  deletedTeamHistoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `TeamHistory`."""
  team: Team

  """Reads a single `Team` that is related to this `TeamHistory`."""
  antecedentTeam: Team

  """An edge for our `TeamHistory`. May be used by Relay 1."""
  teamHistoryEdge(
    """The method to use when ordering `TeamHistory`."""
    orderBy: [TeamHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamHistoriesEdge
}

"""All input for the `deleteTeamHistoryByNodeId` mutation."""
input DeleteTeamHistoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamHistory` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeamHistory` mutation."""
input DeleteTeamHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  teamId: Int!
  antecedentTeamId: Int!
  startYear: Int!
}

"""The output of our delete `TeamResult` mutation."""
type DeleteTeamResultPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamResult` that was deleted by this mutation."""
  teamResult: TeamResult
  deletedTeamResultNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `TeamResult`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamResult`."""
  team: Team

  """An edge for our `TeamResult`. May be used by Relay 1."""
  teamResultEdge(
    """The method to use when ordering `TeamResult`."""
    orderBy: [TeamResultsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamResultsEdge
}

"""All input for the `deleteTeamResultByNodeId` mutation."""
input DeleteTeamResultByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamResult` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeamResult` mutation."""
input DeleteTeamResultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  constructorResultsId: Int!
}

"""The output of our delete `TeamStanding` mutation."""
type DeleteTeamStandingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TeamStanding` that was deleted by this mutation."""
  teamStanding: TeamStanding
  deletedTeamStandingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Race` that is related to this `TeamStanding`."""
  race: Race

  """Reads a single `Team` that is related to this `TeamStanding`."""
  team: Team

  """An edge for our `TeamStanding`. May be used by Relay 1."""
  teamStandingEdge(
    """The method to use when ordering `TeamStanding`."""
    orderBy: [TeamStandingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamStandingsEdge
}

"""All input for the `deleteTeamStandingByNodeId` mutation."""
input DeleteTeamStandingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TeamStanding` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeamStanding` mutation."""
input DeleteTeamStandingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  constructorStandingsId: Int!
}

"""The output of our delete `Team` mutation."""
type DeleteTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was deleted by this mutation."""
  team: Team
  deletedTeamNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Team`. May be used by Relay 1."""
  teamEdge(
    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TeamsEdge
}

"""All input for the `deleteTeamByNodeId` mutation."""
input DeleteTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Team` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeam` mutation."""
input DeleteTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  teamId: Int!
}

"""All input for the `deleteTeamByConstructorRef` mutation."""
input DeleteTeamByConstructorRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  constructorRef: String!
}
